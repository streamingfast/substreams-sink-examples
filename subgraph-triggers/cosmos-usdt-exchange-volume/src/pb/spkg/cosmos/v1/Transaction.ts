// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v1.3.0

import { Writer, Reader } from "as-proto/assembly";
import { Message } from "./Transaction/Message";
import { Any } from "../../../google/protobuf/Any";
import { Event } from "../../../sf/cosmos/type/v2/Event";
import { AuthInfo } from "../../../cosmos/tx/v1beta1/AuthInfo";

export class Transaction {
  static encode(message: Transaction, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.rawTx);

    writer.uint32(18);
    writer.string(message.memo);

    writer.uint32(24);
    writer.uint64(message.timeoutHeight);

    const messages = message.messages;
    for (let i: i32 = 0; i < messages.length; ++i) {
      writer.uint32(42);
      writer.fork();
      Message.encode(messages[i], writer);
      writer.ldelim();
    }

    const extensionOptions = message.extensionOptions;
    for (let i: i32 = 0; i < extensionOptions.length; ++i) {
      writer.uint32(8186);
      writer.fork();
      Any.encode(extensionOptions[i], writer);
      writer.ldelim();
    }

    const nonCriticalExtensionOptions = message.nonCriticalExtensionOptions;
    for (let i: i32 = 0; i < nonCriticalExtensionOptions.length; ++i) {
      writer.uint32(16378);
      writer.fork();
      Any.encode(nonCriticalExtensionOptions[i], writer);
      writer.ldelim();
    }

    writer.uint32(168);
    writer.uint32(message.resultCode);

    writer.uint32(178);
    writer.bytes(message.resultData);

    writer.uint32(186);
    writer.string(message.resultLog);

    writer.uint32(194);
    writer.string(message.resultInfo);

    writer.uint32(200);
    writer.int64(message.resultGasWanted);

    writer.uint32(208);
    writer.int64(message.resultGasUsed);

    const resultEvents = message.resultEvents;
    for (let i: i32 = 0; i < resultEvents.length; ++i) {
      writer.uint32(218);
      writer.fork();
      Event.encode(resultEvents[i], writer);
      writer.ldelim();
    }

    writer.uint32(226);
    writer.string(message.resultCodespace);

    const authInfo = message.authInfo;
    if (authInfo !== null) {
      writer.uint32(258);
      writer.fork();
      AuthInfo.encode(authInfo, writer);
      writer.ldelim();
    }

    const signatures = message.signatures;
    if (signatures.length !== 0) {
      for (let i: i32 = 0; i < signatures.length; ++i) {
        writer.uint32(266);
        writer.bytes(signatures[i]);
      }
    }
  }

  static decode(reader: Reader, length: i32): Transaction {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Transaction();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rawTx = reader.bytes();
          break;

        case 2:
          message.memo = reader.string();
          break;

        case 3:
          message.timeoutHeight = reader.uint64();
          break;

        case 5:
          message.messages.push(Message.decode(reader, reader.uint32()));
          break;

        case 1023:
          message.extensionOptions.push(Any.decode(reader, reader.uint32()));
          break;

        case 2047:
          message.nonCriticalExtensionOptions.push(
            Any.decode(reader, reader.uint32())
          );
          break;

        case 21:
          message.resultCode = reader.uint32();
          break;

        case 22:
          message.resultData = reader.bytes();
          break;

        case 23:
          message.resultLog = reader.string();
          break;

        case 24:
          message.resultInfo = reader.string();
          break;

        case 25:
          message.resultGasWanted = reader.int64();
          break;

        case 26:
          message.resultGasUsed = reader.int64();
          break;

        case 27:
          message.resultEvents.push(Event.decode(reader, reader.uint32()));
          break;

        case 28:
          message.resultCodespace = reader.string();
          break;

        case 32:
          message.authInfo = AuthInfo.decode(reader, reader.uint32());
          break;

        case 33:
          message.signatures.push(reader.bytes());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  rawTx: Uint8Array;
  memo: string;
  timeoutHeight: u64;
  messages: Array<Message>;
  extensionOptions: Array<Any>;
  nonCriticalExtensionOptions: Array<Any>;
  resultCode: u32;
  resultData: Uint8Array;
  resultLog: string;
  resultInfo: string;
  resultGasWanted: i64;
  resultGasUsed: i64;
  resultEvents: Array<Event>;
  resultCodespace: string;
  authInfo: AuthInfo | null;
  signatures: Array<Uint8Array>;

  constructor(
    rawTx: Uint8Array = new Uint8Array(0),
    memo: string = "",
    timeoutHeight: u64 = 0,
    messages: Array<Message> = [],
    extensionOptions: Array<Any> = [],
    nonCriticalExtensionOptions: Array<Any> = [],
    resultCode: u32 = 0,
    resultData: Uint8Array = new Uint8Array(0),
    resultLog: string = "",
    resultInfo: string = "",
    resultGasWanted: i64 = 0,
    resultGasUsed: i64 = 0,
    resultEvents: Array<Event> = [],
    resultCodespace: string = "",
    authInfo: AuthInfo | null = null,
    signatures: Array<Uint8Array> = []
  ) {
    this.rawTx = rawTx;
    this.memo = memo;
    this.timeoutHeight = timeoutHeight;
    this.messages = messages;
    this.extensionOptions = extensionOptions;
    this.nonCriticalExtensionOptions = nonCriticalExtensionOptions;
    this.resultCode = resultCode;
    this.resultData = resultData;
    this.resultLog = resultLog;
    this.resultInfo = resultInfo;
    this.resultGasWanted = resultGasWanted;
    this.resultGasUsed = resultGasUsed;
    this.resultEvents = resultEvents;
    this.resultCodespace = resultCodespace;
    this.authInfo = authInfo;
    this.signatures = signatures;
  }
}
