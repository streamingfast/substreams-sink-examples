// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v1.3.0

import { Writer, Reader } from "as-proto/assembly";
import { UninterpretedOption } from "./UninterpretedOption";
import { CType } from "./FieldOptions/CType";
import { JSType } from "./FieldOptions/JSType";
import { OptionRetention } from "./FieldOptions/OptionRetention";
import { OptionTargetType } from "./FieldOptions/OptionTargetType";

export class FieldOptions {
  static encode(message: FieldOptions, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.ctype);

    writer.uint32(16);
    writer.bool(message.packed);

    writer.uint32(48);
    writer.int32(message.jstype);

    writer.uint32(40);
    writer.bool(message.lazy);

    writer.uint32(120);
    writer.bool(message.unverifiedLazy);

    writer.uint32(24);
    writer.bool(message.deprecated);

    writer.uint32(80);
    writer.bool(message.weak);

    writer.uint32(128);
    writer.bool(message.debugRedact);

    writer.uint32(136);
    writer.int32(message.retention);

    writer.uint32(144);
    writer.int32(message.target);

    const targets = message.targets;
    if (targets.length !== 0) {
      for (let i: i32 = 0; i < targets.length; ++i) {
        writer.uint32(152);
        writer.int32(targets[i]);
      }
    }

    const uninterpretedOption = message.uninterpretedOption;
    for (let i: i32 = 0; i < uninterpretedOption.length; ++i) {
      writer.uint32(7994);
      writer.fork();
      UninterpretedOption.encode(uninterpretedOption[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): FieldOptions {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new FieldOptions();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ctype = reader.int32();
          break;

        case 2:
          message.packed = reader.bool();
          break;

        case 6:
          message.jstype = reader.int32();
          break;

        case 5:
          message.lazy = reader.bool();
          break;

        case 15:
          message.unverifiedLazy = reader.bool();
          break;

        case 3:
          message.deprecated = reader.bool();
          break;

        case 10:
          message.weak = reader.bool();
          break;

        case 16:
          message.debugRedact = reader.bool();
          break;

        case 17:
          message.retention = reader.int32();
          break;

        case 18:
          message.target = reader.int32();
          break;

        case 19:
          message.targets.push(reader.int32());
          break;

        case 999:
          message.uninterpretedOption.push(
            UninterpretedOption.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  ctype: CType;
  packed: bool;
  jstype: JSType;
  lazy: bool;
  unverifiedLazy: bool;
  deprecated: bool;
  weak: bool;
  debugRedact: bool;
  retention: OptionRetention;
  target: OptionTargetType;
  targets: Array<OptionTargetType>;
  uninterpretedOption: Array<UninterpretedOption>;

  constructor(
    ctype: CType = CType.STRING,
    packed: bool = false,
    jstype: JSType = JSType.JS_NORMAL,
    lazy: bool = false,
    unverifiedLazy: bool = false,
    deprecated: bool = false,
    weak: bool = false,
    debugRedact: bool = false,
    retention: OptionRetention = 0,
    target: OptionTargetType = 0,
    targets: Array<OptionTargetType> = [],
    uninterpretedOption: Array<UninterpretedOption> = []
  ) {
    this.ctype = ctype;
    this.packed = packed;
    this.jstype = jstype;
    this.lazy = lazy;
    this.unverifiedLazy = unverifiedLazy;
    this.deprecated = deprecated;
    this.weak = weak;
    this.debugRedact = debugRedact;
    this.retention = retention;
    this.target = target;
    this.targets = targets;
    this.uninterpretedOption = uninterpretedOption;
  }
}
