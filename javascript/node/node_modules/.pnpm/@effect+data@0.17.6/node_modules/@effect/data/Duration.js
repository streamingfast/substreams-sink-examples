"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zero = exports.weeks = exports.unsafeToNanos = exports.toNanos = exports.toMillis = exports.toHrTime = exports.times = exports.sum = exports.seconds = exports.nanos = exports.minutes = exports.min = exports.millis = exports.micros = exports.max = exports.matchWith = exports.match = exports.lessThanOrEqualTo = exports.lessThan = exports.isDuration = exports.infinity = exports.hours = exports.greaterThanOrEqualTo = exports.greaterThan = exports.equals = exports.decode = exports.days = exports.clamp = exports.between = exports.Order = exports.Equivalence = void 0;
var Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Equal"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Hash"));
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var order = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Order"));
var _Pipeable = /*#__PURE__*/require("@effect/data/Pipeable");
var _Predicate = /*#__PURE__*/require("@effect/data/Predicate");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 */

const TypeId = /*#__PURE__*/Symbol.for("@effect/data/Duration");
const bigint1e3 = /*#__PURE__*/BigInt(1000);
const bigint1e9 = /*#__PURE__*/BigInt(1000000000);
const DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos|micros|millis|seconds|minutes|hours|days|weeks)$/;
/**
 * @since 1.0.0
 */
const decode = input => {
  if (isDuration(input)) {
    return input;
  } else if ((0, _Predicate.isNumber)(input)) {
    return millis(input);
  } else if ((0, _Predicate.isBigint)(input)) {
    return nanos(input);
  } else {
    DURATION_REGEX.lastIndex = 0; // Reset the lastIndex before each use
    const match = DURATION_REGEX.exec(input);
    if (match) {
      const [_, valueStr, unit] = match;
      const value = Number(valueStr);
      switch (unit) {
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micros":
          return micros(BigInt(valueStr));
        case "millis":
          return millis(value);
        case "seconds":
          return seconds(value);
        case "minutes":
          return minutes(value);
        case "hours":
          return hours(value);
        case "days":
          return days(value);
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid duration input");
};
exports.decode = decode;
const zeroValue = {
  _tag: "Millis",
  millis: 0
};
const infinityValue = {
  _tag: "Infinity"
};
class DurationImpl {
  constructor(input) {
    this._id = TypeId;
    if ((0, _Predicate.isNumber)(input)) {
      if (isNaN(input) || input < 0) {
        this.value = zeroValue;
      } else if (!Number.isFinite(input)) {
        this.value = infinityValue;
      } else if (!Number.isInteger(input)) {
        this.value = {
          _tag: "Nanos",
          nanos: BigInt(Math.round(input * 1000000))
        };
      } else {
        this.value = {
          _tag: "Millis",
          millis: input
        };
      }
    } else if (input < BigInt(0)) {
      this.value = zeroValue;
    } else {
      this.value = {
        _tag: "Nanos",
        nanos: input
      };
    }
  }
  [Hash.symbol]() {
    return Hash.structure(this.value);
  }
  [Equal.symbol](that) {
    return isDuration(that) && equals(this, that);
  }
  toString() {
    switch (this.value._tag) {
      case "Millis":
        return `Duration("${this.value.millis} millis")`;
      case "Nanos":
        return `Duration("${this.value.nanos} nanos")`;
      case "Infinity":
        return "Duration(Infinity)";
    }
  }
  toJSON() {
    if (this.value._tag === "Nanos") {
      return {
        _tag: "Duration",
        value: {
          _tag: "Nanos",
          hrtime: toHrTime(this)
        }
      };
    }
    return {
      _tag: "Duration",
      value: this.value
    };
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toJSON();
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/**
 * @since 1.0.0
 * @category guards
 */
const isDuration = u => (0, _Predicate.isObject)(u) && "_id" in u && u["_id"] === TypeId;
/**
 * @since 1.0.0
 * @category constructors
 */
exports.isDuration = isDuration;
const zero = /*#__PURE__*/new DurationImpl(0);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.zero = zero;
const infinity = /*#__PURE__*/new DurationImpl(Infinity);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.infinity = infinity;
const nanos = nanos => new DurationImpl(nanos);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.nanos = nanos;
const micros = micros => new DurationImpl(micros * bigint1e3);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.micros = micros;
const millis = millis => new DurationImpl(millis);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.millis = millis;
const seconds = seconds => new DurationImpl(seconds * 1000);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.seconds = seconds;
const minutes = minutes => new DurationImpl(minutes * 60000);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.minutes = minutes;
const hours = hours => new DurationImpl(hours * 3600000);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.hours = hours;
const days = days => new DurationImpl(days * 86400000);
/**
 * @since 1.0.0
 * @category constructors
 */
exports.days = days;
const weeks = weeks => new DurationImpl(weeks * 604800000);
/**
 * @since 1.0.0
 * @category getters
 */
exports.weeks = weeks;
const toMillis = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return Infinity;
    case "Nanos":
      return Number(_self.value.nanos) / 1000000;
    case "Millis":
      return _self.value.millis;
  }
};
/**
 * Get the duration in nanoseconds as a bigint.
 *
 * If the duration is infinite, returns `Option.none()`
 *
 * @since 1.0.0
 * @category getters
 */
exports.toMillis = toMillis;
const toNanos = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return Option.none();
    case "Nanos":
      return Option.some(_self.value.nanos);
    case "Millis":
      return Option.some(BigInt(Math.round(_self.value.millis * 1000000)));
  }
};
/**
 * Get the duration in nanoseconds as a bigint.
 *
 * If the duration is infinite, it throws an error.
 *
 * @since 1.0.0
 * @category getters
 */
exports.toNanos = toNanos;
const unsafeToNanos = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1000000));
  }
};
/**
 * @since 1.0.0
 * @category getters
 */
exports.unsafeToNanos = unsafeToNanos;
const toHrTime = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1000000)];
  }
};
/**
 * @since 1.0.0
 * @category pattern matching
 */
exports.toHrTime = toHrTime;
const match = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
/**
 * @since 1.0.0
 * @category pattern matching
 */
exports.match = match;
const matchWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1000000));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1000000));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
/**
 * @category instances
 * @since 1.0.0
 */
exports.matchWith = matchWith;
const Order = /*#__PURE__*/order.make((self, that) => matchWith(self, that, {
  onMillis: (self, that) => self < that ? -1 : self > that ? 1 : 0,
  onNanos: (self, that) => self < that ? -1 : self > that ? 1 : 0
}));
/**
 * Checks if a `Duration` is between a `minimum` and `maximum` value.
 *
 * @category predicates
 * @since 1.0.0
 */
exports.Order = Order;
const between = /*#__PURE__*/order.between( /*#__PURE__*/order.mapInput(Order, decode));
/**
 * @category instances
 * @since 1.0.0
 */
exports.between = between;
const Equivalence = (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self === that,
  onNanos: (self, that) => self === that
});
exports.Equivalence = Equivalence;
const _min = /*#__PURE__*/order.min(Order);
/**
 * @since 1.0.0
 */
const min = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => _min(decode(self), decode(that)));
exports.min = min;
const _max = /*#__PURE__*/order.max(Order);
/**
 * @since 1.0.0
 */
const max = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => _max(decode(self), decode(that)));
exports.max = max;
const _clamp = /*#__PURE__*/order.clamp(Order);
/**
 * @since 1.0.0
 */
const clamp = /*#__PURE__*/(0, _Function.dual)(3, (self, minimum, maximum) => _clamp(decode(self), decode(minimum), decode(maximum)));
/**
 * @since 1.0.0
 * @category math
 */
exports.clamp = clamp;
const times = /*#__PURE__*/(0, _Function.dual)(2, (self, times) => match(self, {
  onMillis: millis => new DurationImpl(millis * times),
  onNanos: nanos => new DurationImpl(nanos * BigInt(times))
}));
/**
 * @since 1.0.0
 * @category math
 */
exports.times = times;
const sum = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => new DurationImpl(self + that),
  onNanos: (self, that) => new DurationImpl(self + that)
}));
/**
 * @since 1.0.0
 * @category predicates
 */
exports.sum = sum;
const lessThan = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self < that,
  onNanos: (self, that) => self < that
}));
/**
 * @since 1.0.0
 * @category predicates
 */
exports.lessThan = lessThan;
const lessThanOrEqualTo = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self <= that,
  onNanos: (self, that) => self <= that
}));
/**
 * @since 1.0.0
 * @category predicates
 */
exports.lessThanOrEqualTo = lessThanOrEqualTo;
const greaterThan = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self > that,
  onNanos: (self, that) => self > that
}));
/**
 * @since 1.0.0
 * @category predicates
 */
exports.greaterThan = greaterThan;
const greaterThanOrEqualTo = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self >= that,
  onNanos: (self, that) => self >= that
}));
/**
 * @since 1.0.0
 * @category predicates
 */
exports.greaterThanOrEqualTo = greaterThanOrEqualTo;
const equals = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => Equivalence(decode(self), decode(that)));
exports.equals = equals;
//# sourceMappingURL=Duration.js.map