/**
 * @since 1.0.0
 */
import * as Equal from "@effect/data/Equal";
import * as Hash from "@effect/data/Hash";
const protoArr = /*#__PURE__*/(() => {
  const proto = {
    [Hash.symbol]() {
      return Hash.array(this);
    },
    [Equal.symbol](that) {
      if (Array.isArray(that) && this.length === that.length) {
        return this.every((v, i) => Equal.equals(v, that[i]));
      } else {
        return false;
      }
    }
  };
  return Object.setPrototypeOf(proto, Array.prototype);
})();
const protoStruct = /*#__PURE__*/(() => {
  const proto = {
    [Hash.symbol]() {
      return Hash.structure(this);
    },
    [Equal.symbol](that) {
      const selfKeys = Object.keys(this);
      const thatKeys = Object.keys(that);
      if (selfKeys.length !== thatKeys.length) {
        return false;
      }
      for (const key of selfKeys) {
        if (!(key in that && Equal.equals(this[key], that[key]))) {
          return false;
        }
      }
      return true;
    }
  };
  return Object.setPrototypeOf(proto, Object.prototype);
})();
/**
 * @category constructors
 * @since 1.0.0
 */
export const struct = as => unsafeStruct(Object.assign({}, as));
/**
 * @category constructors
 * @since 1.0.0
 */
export const unsafeStruct = as => Object.setPrototypeOf(as, protoStruct);
/**
 * @category constructors
 * @since 1.0.0
 */
export const tuple = (...as) => unsafeArray(as);
/**
 * @category constructors
 * @since 1.0.0
 */
export const array = as => unsafeArray(as.slice(0));
/**
 * @category constructors
 * @since 1.0.0
 */
export const unsafeArray = as => Object.setPrototypeOf(as, protoArr);
const _case = () => args => args === undefined ? struct({}) : struct(args);
export {
/**
 * Provides a constructor for the specified `Case`.
 *
 * @since 1.0.0
 * @category constructors
 */
_case as case };
/**
 * Provides a tagged constructor for the specified `Case`.
 *
 * @since 1.0.0
 * @category constructors
 */
export const tagged = tag =>
// @ts-expect-error
args => args === undefined ? struct({
  _tag: tag
}) : struct({
  ...args,
  _tag: tag
});
/**
 * Provides a Tagged constructor for a Case Class.
 *
 * @since 1.0.0
 * @category constructors
 */
export const TaggedClass = tag => {
  class Base extends Class {
    constructor() {
      super(...arguments);
      this._tag = tag;
    }
  }
  return Base;
};
/**
 * Provides a constructor for a Case Class.
 *
 * @since 1.0.0
 * @category constructors
 */
export const Class = /*#__PURE__*/(() => {
  class Base {
    constructor(args) {
      if (args) {
        Object.assign(this, args);
      }
    }
    [Hash.symbol]() {
      return Hash.structure(this);
    }
    [Equal.symbol](that) {
      const selfKeys = Object.keys(this);
      const thatKeys = Object.keys(that);
      if (selfKeys.length !== thatKeys.length) {
        return false;
      }
      for (const key of selfKeys) {
        if (!(key in that && Equal.equals(this[key], that[key]))) {
          return false;
        }
      }
      return true;
    }
  }
  return Base;
})();
/**
 * Create a constructor for a tagged union of `Data` structs.
 *
 * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to
 * the constructor.
 *
 * @example
 * import * as Data from "@effect/data/Data"
 *
 * const HttpError = Data.taggedEnum<
 *   | Data.Data<{ _tag: "BadRequest"; status: 400; message: string }>
 *   | Data.Data<{ _tag: "NotFound"; status: 404; message: string }>
 * >()
 *
 * const notFound = HttpError("NotFound")({ status: 404, message: "Not Found" })
 *
 * @example
 * import * as Data from "@effect/data/Data"
 *
 * type MyResult<E, A> = Data.TaggedEnum<{
 *   Failure: { error: E }
 *   Success: { value: A }
 * }>
 * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {
 *   readonly taggedEnum: MyResult<this["A"], this["B"]>
 * }
 * const MyResult = Data.taggedEnum<MyResultDefinition>()
 *
 * const success = MyResult("Success")({ value: 1 })
 *
 * @category constructors
 * @since 1.0.0
 */
export const taggedEnum = () => tagged;
//# sourceMappingURL=Data.mjs.map