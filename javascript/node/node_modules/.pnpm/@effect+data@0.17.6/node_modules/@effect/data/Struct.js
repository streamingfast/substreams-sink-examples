"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pick = exports.omit = exports.getOrder = exports.getEquivalence = exports.evolve = void 0;
var Equivalence = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Equivalence"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var order = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Order"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * This module provides utility functions for working with structs in TypeScript.
 *
 * @since 1.0.0
 */

/**
 * Create a new object by picking properties of an existing object.
 *
 * @example
 * import { pick } from "@effect/data/Struct"
 * import { pipe } from "@effect/data/Function"
 *
 * assert.deepStrictEqual(pipe({ a: "a", b: 1, c: true }, pick("a", "b")), { a: "a", b: 1 })
 *
 * @since 1.0.0
 */
const pick = (...keys) => s => {
  const out = {};
  for (const k of keys) {
    out[k] = s[k];
  }
  return out;
};
/**
 * Create a new object by omitting properties of an existing object.
 *
 * @example
 * import { omit } from "@effect/data/Struct"
 * import { pipe } from "@effect/data/Function"
 *
 * assert.deepStrictEqual(pipe({ a: "a", b: 1, c: true }, omit("c")), { a: "a", b: 1 })
 *
 * @since 1.0.0
 */
exports.pick = pick;
const omit = (...keys) => s => {
  const out = {
    ...s
  };
  for (const k of keys) {
    delete out[k];
  }
  return out;
};
/**
 * Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct
 * by applying each `Equivalence` to the corresponding property of the struct.
 *
 * Alias of {@link Equivalence.struct}.
 *
 * @example
 * import { getEquivalence } from "@effect/data/Struct"
 * import * as S from "@effect/data/String"
 * import * as N from "@effect/data/Number"
 *
 * const PersonEquivalence = getEquivalence({
 *   name: S.Equivalence,
 *   age: N.Equivalence
 * })
 *
 * assert.deepStrictEqual(
 *   PersonEquivalence({ name: "John", age: 25 }, { name: "John", age: 25 }),
 *   true
 * )
 * assert.deepStrictEqual(
 *   PersonEquivalence({ name: "John", age: 25 }, { name: "John", age: 40 }),
 *   false
 * )
 *
 * @category combinators
 * @since 1.0.0
 */
exports.omit = omit;
const getEquivalence = Equivalence.struct;
/**
 * This function creates and returns a new `Order` for a struct of values based on the given `Order`s
 * for each property in the struct.
 *
 * Alias of {@link order.struct}.
 *
 * @category combinators
 * @since 1.0.0
 */
exports.getEquivalence = getEquivalence;
const getOrder = order.struct;
/**
 * Transforms the values of a Struct provided a transformation function for each key.
 * If no transformation function is provided for a key, it will return the origional value for that key.
 *
 * @example
 * import { evolve } from '@effect/data/Struct'
 * import { pipe } from '@effect/data/Function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     { a: 'a', b: 1, c: 3 },
 *     evolve({
 *       a: (a) => a.length,
 *       b: (b) => b * 2
 *     })
 *   ),
 *   { a: 1, b: 2, c: 3 }
 * )
 *
 * @since 1.0.0
 */
exports.getOrder = getOrder;
const evolve = /*#__PURE__*/(0, _Function.dual)(2, (obj, t) => {
  const out = {
    ...obj
  };
  for (const k in t) {
    if (Object.prototype.hasOwnProperty.call(obj, k)) {
      // @ts-expect-error
      out[k] = t[k](obj[k]);
    }
  }
  return out;
});
exports.evolve = evolve;
//# sourceMappingURL=Struct.js.map