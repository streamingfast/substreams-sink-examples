"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unsafeStruct = exports.unsafeArray = exports.tuple = exports.taggedEnum = exports.tagged = exports.struct = exports.case = exports.array = exports.TaggedClass = exports.Class = void 0;
var Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Equal"));
var Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Hash"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 */

const protoArr = /*#__PURE__*/(() => {
  const proto = {
    [Hash.symbol]() {
      return Hash.array(this);
    },
    [Equal.symbol](that) {
      if (Array.isArray(that) && this.length === that.length) {
        return this.every((v, i) => Equal.equals(v, that[i]));
      } else {
        return false;
      }
    }
  };
  return Object.setPrototypeOf(proto, Array.prototype);
})();
const protoStruct = /*#__PURE__*/(() => {
  const proto = {
    [Hash.symbol]() {
      return Hash.structure(this);
    },
    [Equal.symbol](that) {
      const selfKeys = Object.keys(this);
      const thatKeys = Object.keys(that);
      if (selfKeys.length !== thatKeys.length) {
        return false;
      }
      for (const key of selfKeys) {
        if (!(key in that && Equal.equals(this[key], that[key]))) {
          return false;
        }
      }
      return true;
    }
  };
  return Object.setPrototypeOf(proto, Object.prototype);
})();
/**
 * @category constructors
 * @since 1.0.0
 */
const struct = as => unsafeStruct(Object.assign({}, as));
/**
 * @category constructors
 * @since 1.0.0
 */
exports.struct = struct;
const unsafeStruct = as => Object.setPrototypeOf(as, protoStruct);
/**
 * @category constructors
 * @since 1.0.0
 */
exports.unsafeStruct = unsafeStruct;
const tuple = (...as) => unsafeArray(as);
/**
 * @category constructors
 * @since 1.0.0
 */
exports.tuple = tuple;
const array = as => unsafeArray(as.slice(0));
/**
 * @category constructors
 * @since 1.0.0
 */
exports.array = array;
const unsafeArray = as => Object.setPrototypeOf(as, protoArr);
exports.unsafeArray = unsafeArray;
const _case = () => args => args === undefined ? struct({}) : struct(args);
exports.case = _case;
/**
 * Provides a tagged constructor for the specified `Case`.
 *
 * @since 1.0.0
 * @category constructors
 */
const tagged = tag =>
// @ts-expect-error
args => args === undefined ? struct({
  _tag: tag
}) : struct({
  ...args,
  _tag: tag
});
/**
 * Provides a Tagged constructor for a Case Class.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.tagged = tagged;
const TaggedClass = tag => {
  class Base extends Class {
    constructor() {
      super(...arguments);
      this._tag = tag;
    }
  }
  return Base;
};
/**
 * Provides a constructor for a Case Class.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.TaggedClass = TaggedClass;
const Class = /*#__PURE__*/(() => {
  class Base {
    constructor(args) {
      if (args) {
        Object.assign(this, args);
      }
    }
    [Hash.symbol]() {
      return Hash.structure(this);
    }
    [Equal.symbol](that) {
      const selfKeys = Object.keys(this);
      const thatKeys = Object.keys(that);
      if (selfKeys.length !== thatKeys.length) {
        return false;
      }
      for (const key of selfKeys) {
        if (!(key in that && Equal.equals(this[key], that[key]))) {
          return false;
        }
      }
      return true;
    }
  }
  return Base;
})();
/**
 * Create a constructor for a tagged union of `Data` structs.
 *
 * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to
 * the constructor.
 *
 * @example
 * import * as Data from "@effect/data/Data"
 *
 * const HttpError = Data.taggedEnum<
 *   | Data.Data<{ _tag: "BadRequest"; status: 400; message: string }>
 *   | Data.Data<{ _tag: "NotFound"; status: 404; message: string }>
 * >()
 *
 * const notFound = HttpError("NotFound")({ status: 404, message: "Not Found" })
 *
 * @example
 * import * as Data from "@effect/data/Data"
 *
 * type MyResult<E, A> = Data.TaggedEnum<{
 *   Failure: { error: E }
 *   Success: { value: A }
 * }>
 * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {
 *   readonly taggedEnum: MyResult<this["A"], this["B"]>
 * }
 * const MyResult = Data.taggedEnum<MyResultDefinition>()
 *
 * const success = MyResult("Success")({ value: 1 })
 *
 * @category constructors
 * @since 1.0.0
 */
exports.Class = Class;
const taggedEnum = () => tagged;
exports.taggedEnum = taggedEnum;
//# sourceMappingURL=Data.js.map