/**
 * @since 1.0.0
 */
import * as Equal from "@effect/data/Equal";
import { dual } from "@effect/data/Function";
import * as Hash from "@effect/data/Hash";
import * as Option from "@effect/data/Option";
import * as order from "@effect/data/Order";
import { pipeArguments } from "@effect/data/Pipeable";
import { isBigint, isNumber, isObject } from "@effect/data/Predicate";
const TypeId = /*#__PURE__*/Symbol.for("@effect/data/Duration");
const bigint1e3 = /*#__PURE__*/BigInt(1000);
const bigint1e9 = /*#__PURE__*/BigInt(1000000000);
const DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos|micros|millis|seconds|minutes|hours|days|weeks)$/;
/**
 * @since 1.0.0
 */
export const decode = input => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigint(input)) {
    return nanos(input);
  } else {
    DURATION_REGEX.lastIndex = 0; // Reset the lastIndex before each use
    const match = DURATION_REGEX.exec(input);
    if (match) {
      const [_, valueStr, unit] = match;
      const value = Number(valueStr);
      switch (unit) {
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micros":
          return micros(BigInt(valueStr));
        case "millis":
          return millis(value);
        case "seconds":
          return seconds(value);
        case "minutes":
          return minutes(value);
        case "hours":
          return hours(value);
        case "days":
          return days(value);
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid duration input");
};
const zeroValue = {
  _tag: "Millis",
  millis: 0
};
const infinityValue = {
  _tag: "Infinity"
};
class DurationImpl {
  constructor(input) {
    this._id = TypeId;
    if (isNumber(input)) {
      if (isNaN(input) || input < 0) {
        this.value = zeroValue;
      } else if (!Number.isFinite(input)) {
        this.value = infinityValue;
      } else if (!Number.isInteger(input)) {
        this.value = {
          _tag: "Nanos",
          nanos: BigInt(Math.round(input * 1000000))
        };
      } else {
        this.value = {
          _tag: "Millis",
          millis: input
        };
      }
    } else if (input < BigInt(0)) {
      this.value = zeroValue;
    } else {
      this.value = {
        _tag: "Nanos",
        nanos: input
      };
    }
  }
  [Hash.symbol]() {
    return Hash.structure(this.value);
  }
  [Equal.symbol](that) {
    return isDuration(that) && equals(this, that);
  }
  toString() {
    switch (this.value._tag) {
      case "Millis":
        return `Duration("${this.value.millis} millis")`;
      case "Nanos":
        return `Duration("${this.value.nanos} nanos")`;
      case "Infinity":
        return "Duration(Infinity)";
    }
  }
  toJSON() {
    if (this.value._tag === "Nanos") {
      return {
        _tag: "Duration",
        value: {
          _tag: "Nanos",
          hrtime: toHrTime(this)
        }
      };
    }
    return {
      _tag: "Duration",
      value: this.value
    };
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toJSON();
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/**
 * @since 1.0.0
 * @category guards
 */
export const isDuration = u => isObject(u) && "_id" in u && u["_id"] === TypeId;
/**
 * @since 1.0.0
 * @category constructors
 */
export const zero = /*#__PURE__*/new DurationImpl(0);
/**
 * @since 1.0.0
 * @category constructors
 */
export const infinity = /*#__PURE__*/new DurationImpl(Infinity);
/**
 * @since 1.0.0
 * @category constructors
 */
export const nanos = nanos => new DurationImpl(nanos);
/**
 * @since 1.0.0
 * @category constructors
 */
export const micros = micros => new DurationImpl(micros * bigint1e3);
/**
 * @since 1.0.0
 * @category constructors
 */
export const millis = millis => new DurationImpl(millis);
/**
 * @since 1.0.0
 * @category constructors
 */
export const seconds = seconds => new DurationImpl(seconds * 1000);
/**
 * @since 1.0.0
 * @category constructors
 */
export const minutes = minutes => new DurationImpl(minutes * 60000);
/**
 * @since 1.0.0
 * @category constructors
 */
export const hours = hours => new DurationImpl(hours * 3600000);
/**
 * @since 1.0.0
 * @category constructors
 */
export const days = days => new DurationImpl(days * 86400000);
/**
 * @since 1.0.0
 * @category constructors
 */
export const weeks = weeks => new DurationImpl(weeks * 604800000);
/**
 * @since 1.0.0
 * @category getters
 */
export const toMillis = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return Infinity;
    case "Nanos":
      return Number(_self.value.nanos) / 1000000;
    case "Millis":
      return _self.value.millis;
  }
};
/**
 * Get the duration in nanoseconds as a bigint.
 *
 * If the duration is infinite, returns `Option.none()`
 *
 * @since 1.0.0
 * @category getters
 */
export const toNanos = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return Option.none();
    case "Nanos":
      return Option.some(_self.value.nanos);
    case "Millis":
      return Option.some(BigInt(Math.round(_self.value.millis * 1000000)));
  }
};
/**
 * Get the duration in nanoseconds as a bigint.
 *
 * If the duration is infinite, it throws an error.
 *
 * @since 1.0.0
 * @category getters
 */
export const unsafeToNanos = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1000000));
  }
};
/**
 * @since 1.0.0
 * @category getters
 */
export const toHrTime = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1000000)];
  }
};
/**
 * @since 1.0.0
 * @category pattern matching
 */
export const match = /*#__PURE__*/dual(2, (self, options) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
/**
 * @since 1.0.0
 * @category pattern matching
 */
export const matchWith = /*#__PURE__*/dual(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1000000));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1000000));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
/**
 * @category instances
 * @since 1.0.0
 */
export const Order = /*#__PURE__*/order.make((self, that) => matchWith(self, that, {
  onMillis: (self, that) => self < that ? -1 : self > that ? 1 : 0,
  onNanos: (self, that) => self < that ? -1 : self > that ? 1 : 0
}));
/**
 * Checks if a `Duration` is between a `minimum` and `maximum` value.
 *
 * @category predicates
 * @since 1.0.0
 */
export const between = /*#__PURE__*/order.between( /*#__PURE__*/order.mapInput(Order, decode));
/**
 * @category instances
 * @since 1.0.0
 */
export const Equivalence = (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self === that,
  onNanos: (self, that) => self === that
});
const _min = /*#__PURE__*/order.min(Order);
/**
 * @since 1.0.0
 */
export const min = /*#__PURE__*/dual(2, (self, that) => _min(decode(self), decode(that)));
const _max = /*#__PURE__*/order.max(Order);
/**
 * @since 1.0.0
 */
export const max = /*#__PURE__*/dual(2, (self, that) => _max(decode(self), decode(that)));
const _clamp = /*#__PURE__*/order.clamp(Order);
/**
 * @since 1.0.0
 */
export const clamp = /*#__PURE__*/dual(3, (self, minimum, maximum) => _clamp(decode(self), decode(minimum), decode(maximum)));
/**
 * @since 1.0.0
 * @category math
 */
export const times = /*#__PURE__*/dual(2, (self, times) => match(self, {
  onMillis: millis => new DurationImpl(millis * times),
  onNanos: nanos => new DurationImpl(nanos * BigInt(times))
}));
/**
 * @since 1.0.0
 * @category math
 */
export const sum = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => new DurationImpl(self + that),
  onNanos: (self, that) => new DurationImpl(self + that)
}));
/**
 * @since 1.0.0
 * @category predicates
 */
export const lessThan = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self < that,
  onNanos: (self, that) => self < that
}));
/**
 * @since 1.0.0
 * @category predicates
 */
export const lessThanOrEqualTo = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self <= that,
  onNanos: (self, that) => self <= that
}));
/**
 * @since 1.0.0
 * @category predicates
 */
export const greaterThan = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self > that,
  onNanos: (self, that) => self > that
}));
/**
 * @since 1.0.0
 * @category predicates
 */
export const greaterThanOrEqualTo = /*#__PURE__*/dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self >= that,
  onNanos: (self, that) => self >= that
}));
/**
 * @since 1.0.0
 * @category predicates
 */
export const equals = /*#__PURE__*/dual(2, (self, that) => Equivalence(decode(self), decode(that)));
//# sourceMappingURL=Duration.mjs.map