// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file sf/substreams/v1/modules.proto (package sf.substreams.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
/**
 * @generated from message sf.substreams.v1.Modules
 */
export class Modules extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated sf.substreams.v1.Module modules = 1;
         */
        Object.defineProperty(this, "modules", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * @generated from field: repeated sf.substreams.v1.Binary binaries = 2;
         */
        Object.defineProperty(this, "binaries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Modules().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Modules().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Modules().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Modules, a, b);
    }
}
Object.defineProperty(Modules, "runtime", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3
});
Object.defineProperty(Modules, "typeName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "sf.substreams.v1.Modules"
});
Object.defineProperty(Modules, "fields", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3.util.newFieldList(() => [
        { no: 1, name: "modules", kind: "message", T: Module, repeated: true },
        { no: 2, name: "binaries", kind: "message", T: Binary, repeated: true },
    ])
});
/**
 * Binary represents some code compiled to its binary form.
 *
 * @generated from message sf.substreams.v1.Binary
 */
export class Binary extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string type = 1;
         */
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        /**
         * @generated from field: bytes content = 2;
         */
        Object.defineProperty(this, "content", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Uint8Array(0)
        });
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Binary().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Binary().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Binary().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Binary, a, b);
    }
}
Object.defineProperty(Binary, "runtime", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3
});
Object.defineProperty(Binary, "typeName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "sf.substreams.v1.Binary"
});
Object.defineProperty(Binary, "fields", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "content", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    ])
});
/**
 * @generated from message sf.substreams.v1.Module
 */
export class Module extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string name = 1;
         */
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        /**
         * @generated from oneof sf.substreams.v1.Module.kind
         */
        Object.defineProperty(this, "kind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { case: undefined }
        });
        /**
         * @generated from field: uint32 binary_index = 4;
         */
        Object.defineProperty(this, "binaryIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /**
         * @generated from field: string binary_entrypoint = 5;
         */
        Object.defineProperty(this, "binaryEntrypoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        /**
         * @generated from field: repeated sf.substreams.v1.Module.Input inputs = 6;
         */
        Object.defineProperty(this, "inputs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * @generated from field: sf.substreams.v1.Module.Output output = 7;
         */
        Object.defineProperty(this, "output", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * @generated from field: uint64 initial_block = 8;
         */
        Object.defineProperty(this, "initialBlock", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: protoInt64.zero
        });
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Module().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Module().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Module().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Module, a, b);
    }
}
Object.defineProperty(Module, "runtime", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3
});
Object.defineProperty(Module, "typeName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "sf.substreams.v1.Module"
});
Object.defineProperty(Module, "fields", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "kind_map", kind: "message", T: Module_KindMap, oneof: "kind" },
        { no: 3, name: "kind_store", kind: "message", T: Module_KindStore, oneof: "kind" },
        { no: 4, name: "binary_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
        { no: 5, name: "binary_entrypoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 6, name: "inputs", kind: "message", T: Module_Input, repeated: true },
        { no: 7, name: "output", kind: "message", T: Module_Output },
        { no: 8, name: "initial_block", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    ])
});
/**
 * @generated from message sf.substreams.v1.Module.KindMap
 */
export class Module_KindMap extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string output_type = 1;
         */
        Object.defineProperty(this, "outputType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Module_KindMap().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Module_KindMap().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Module_KindMap().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Module_KindMap, a, b);
    }
}
Object.defineProperty(Module_KindMap, "runtime", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3
});
Object.defineProperty(Module_KindMap, "typeName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "sf.substreams.v1.Module.KindMap"
});
Object.defineProperty(Module_KindMap, "fields", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3.util.newFieldList(() => [
        { no: 1, name: "output_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ])
});
/**
 * @generated from message sf.substreams.v1.Module.KindStore
 */
export class Module_KindStore extends Message {
    constructor(data) {
        super();
        /**
         * The `update_policy` determines the functions available to mutate the store
         * (like `set()`, `set_if_not_exists()` or `sum()`, etc..) in
         * order to ensure that parallel operations are possible and deterministic
         *
         * Say a store cumulates keys from block 0 to 1M, and a second store
         * cumulates keys from block 1M to 2M. When we want to use this
         * store as a dependency for a downstream module, we will merge the
         * two stores according to this policy.
         *
         * @generated from field: sf.substreams.v1.Module.KindStore.UpdatePolicy update_policy = 1;
         */
        Object.defineProperty(this, "updatePolicy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Module_KindStore_UpdatePolicy.UNSET
        });
        /**
         * @generated from field: string value_type = 2;
         */
        Object.defineProperty(this, "valueType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Module_KindStore().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Module_KindStore().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Module_KindStore().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Module_KindStore, a, b);
    }
}
Object.defineProperty(Module_KindStore, "runtime", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3
});
Object.defineProperty(Module_KindStore, "typeName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "sf.substreams.v1.Module.KindStore"
});
Object.defineProperty(Module_KindStore, "fields", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3.util.newFieldList(() => [
        { no: 1, name: "update_policy", kind: "enum", T: proto3.getEnumType(Module_KindStore_UpdatePolicy) },
        { no: 2, name: "value_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ])
});
/**
 * @generated from enum sf.substreams.v1.Module.KindStore.UpdatePolicy
 */
export var Module_KindStore_UpdatePolicy;
(function (Module_KindStore_UpdatePolicy) {
    /**
     * @generated from enum value: UPDATE_POLICY_UNSET = 0;
     */
    Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["UNSET"] = 0] = "UNSET";
    /**
     * Provides a store where you can `set()` keys, and the latest key wins
     *
     * @generated from enum value: UPDATE_POLICY_SET = 1;
     */
    Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["SET"] = 1] = "SET";
    /**
     * Provides a store where you can `set_if_not_exists()` keys, and the first key wins
     *
     * @generated from enum value: UPDATE_POLICY_SET_IF_NOT_EXISTS = 2;
     */
    Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["SET_IF_NOT_EXISTS"] = 2] = "SET_IF_NOT_EXISTS";
    /**
     * Provides a store where you can `add_*()` keys, where two stores merge by summing its values.
     *
     * @generated from enum value: UPDATE_POLICY_ADD = 3;
     */
    Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["ADD"] = 3] = "ADD";
    /**
     * Provides a store where you can `min_*()` keys, where two stores merge by leaving the minimum value.
     *
     * @generated from enum value: UPDATE_POLICY_MIN = 4;
     */
    Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["MIN"] = 4] = "MIN";
    /**
     * Provides a store where you can `max_*()` keys, where two stores merge by leaving the maximum value.
     *
     * @generated from enum value: UPDATE_POLICY_MAX = 5;
     */
    Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["MAX"] = 5] = "MAX";
    /**
     * Provides a store where you can `append()` keys, where two stores merge by concatenating the bytes in order.
     *
     * @generated from enum value: UPDATE_POLICY_APPEND = 6;
     */
    Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["APPEND"] = 6] = "APPEND";
})(Module_KindStore_UpdatePolicy || (Module_KindStore_UpdatePolicy = {}));
// Retrieve enum metadata with: proto3.getEnumType(Module_KindStore_UpdatePolicy)
proto3.util.setEnumType(Module_KindStore_UpdatePolicy, "sf.substreams.v1.Module.KindStore.UpdatePolicy", [
    { no: 0, name: "UPDATE_POLICY_UNSET" },
    { no: 1, name: "UPDATE_POLICY_SET" },
    { no: 2, name: "UPDATE_POLICY_SET_IF_NOT_EXISTS" },
    { no: 3, name: "UPDATE_POLICY_ADD" },
    { no: 4, name: "UPDATE_POLICY_MIN" },
    { no: 5, name: "UPDATE_POLICY_MAX" },
    { no: 6, name: "UPDATE_POLICY_APPEND" },
]);
/**
 * @generated from message sf.substreams.v1.Module.Input
 */
export class Module_Input extends Message {
    constructor(data) {
        super();
        /**
         * @generated from oneof sf.substreams.v1.Module.Input.input
         */
        Object.defineProperty(this, "input", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { case: undefined }
        });
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Module_Input().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Module_Input().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Module_Input().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Module_Input, a, b);
    }
}
Object.defineProperty(Module_Input, "runtime", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3
});
Object.defineProperty(Module_Input, "typeName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "sf.substreams.v1.Module.Input"
});
Object.defineProperty(Module_Input, "fields", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3.util.newFieldList(() => [
        { no: 1, name: "source", kind: "message", T: Module_Input_Source, oneof: "input" },
        { no: 2, name: "map", kind: "message", T: Module_Input_Map, oneof: "input" },
        { no: 3, name: "store", kind: "message", T: Module_Input_Store, oneof: "input" },
        { no: 4, name: "params", kind: "message", T: Module_Input_Params, oneof: "input" },
    ])
});
/**
 * @generated from message sf.substreams.v1.Module.Input.Source
 */
export class Module_Input_Source extends Message {
    constructor(data) {
        super();
        /**
         * ex: "sf.ethereum.type.v1.Block"
         *
         * @generated from field: string type = 1;
         */
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Module_Input_Source().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Module_Input_Source().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Module_Input_Source().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Module_Input_Source, a, b);
    }
}
Object.defineProperty(Module_Input_Source, "runtime", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3
});
Object.defineProperty(Module_Input_Source, "typeName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "sf.substreams.v1.Module.Input.Source"
});
Object.defineProperty(Module_Input_Source, "fields", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ])
});
/**
 * @generated from message sf.substreams.v1.Module.Input.Map
 */
export class Module_Input_Map extends Message {
    constructor(data) {
        super();
        /**
         * ex: "block_to_pairs"
         *
         * @generated from field: string module_name = 1;
         */
        Object.defineProperty(this, "moduleName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Module_Input_Map().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Module_Input_Map().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Module_Input_Map().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Module_Input_Map, a, b);
    }
}
Object.defineProperty(Module_Input_Map, "runtime", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3
});
Object.defineProperty(Module_Input_Map, "typeName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "sf.substreams.v1.Module.Input.Map"
});
Object.defineProperty(Module_Input_Map, "fields", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3.util.newFieldList(() => [
        { no: 1, name: "module_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ])
});
/**
 * @generated from message sf.substreams.v1.Module.Input.Store
 */
export class Module_Input_Store extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string module_name = 1;
         */
        Object.defineProperty(this, "moduleName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        /**
         * @generated from field: sf.substreams.v1.Module.Input.Store.Mode mode = 2;
         */
        Object.defineProperty(this, "mode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Module_Input_Store_Mode.UNSET
        });
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Module_Input_Store().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Module_Input_Store().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Module_Input_Store().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Module_Input_Store, a, b);
    }
}
Object.defineProperty(Module_Input_Store, "runtime", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3
});
Object.defineProperty(Module_Input_Store, "typeName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "sf.substreams.v1.Module.Input.Store"
});
Object.defineProperty(Module_Input_Store, "fields", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3.util.newFieldList(() => [
        { no: 1, name: "module_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "mode", kind: "enum", T: proto3.getEnumType(Module_Input_Store_Mode) },
    ])
});
/**
 * @generated from enum sf.substreams.v1.Module.Input.Store.Mode
 */
export var Module_Input_Store_Mode;
(function (Module_Input_Store_Mode) {
    /**
     * @generated from enum value: UNSET = 0;
     */
    Module_Input_Store_Mode[Module_Input_Store_Mode["UNSET"] = 0] = "UNSET";
    /**
     * @generated from enum value: GET = 1;
     */
    Module_Input_Store_Mode[Module_Input_Store_Mode["GET"] = 1] = "GET";
    /**
     * @generated from enum value: DELTAS = 2;
     */
    Module_Input_Store_Mode[Module_Input_Store_Mode["DELTAS"] = 2] = "DELTAS";
})(Module_Input_Store_Mode || (Module_Input_Store_Mode = {}));
// Retrieve enum metadata with: proto3.getEnumType(Module_Input_Store_Mode)
proto3.util.setEnumType(Module_Input_Store_Mode, "sf.substreams.v1.Module.Input.Store.Mode", [
    { no: 0, name: "UNSET" },
    { no: 1, name: "GET" },
    { no: 2, name: "DELTAS" },
]);
/**
 * @generated from message sf.substreams.v1.Module.Input.Params
 */
export class Module_Input_Params extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string value = 1;
         */
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Module_Input_Params().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Module_Input_Params().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Module_Input_Params().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Module_Input_Params, a, b);
    }
}
Object.defineProperty(Module_Input_Params, "runtime", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3
});
Object.defineProperty(Module_Input_Params, "typeName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "sf.substreams.v1.Module.Input.Params"
});
Object.defineProperty(Module_Input_Params, "fields", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3.util.newFieldList(() => [
        { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ])
});
/**
 * @generated from message sf.substreams.v1.Module.Output
 */
export class Module_Output extends Message {
    constructor(data) {
        super();
        /**
         * @generated from field: string type = 1;
         */
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Module_Output().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Module_Output().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Module_Output().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Module_Output, a, b);
    }
}
Object.defineProperty(Module_Output, "runtime", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3
});
Object.defineProperty(Module_Output, "typeName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "sf.substreams.v1.Module.Output"
});
Object.defineProperty(Module_Output, "fields", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: proto3.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ])
});
//# sourceMappingURL=modules_pb.js.map