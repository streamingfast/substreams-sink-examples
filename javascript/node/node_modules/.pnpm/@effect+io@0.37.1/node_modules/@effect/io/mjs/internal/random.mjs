var _a;
import * as Chunk from "@effect/data/Chunk";
import * as Context from "@effect/data/Context";
import * as DeterministicRandom from "@effect/data/DeterministicRandom";
import * as core from "@effect/io/internal/core";
/** @internal */
const RandomSymbolKey = "@effect/io/Random";
/** @internal */
export const RandomTypeId = /*#__PURE__*/Symbol.for(RandomSymbolKey);
/** @internal */
export const randomTag = /*#__PURE__*/Context.Tag(RandomTypeId);
/** @internal */
class RandomImpl {
  constructor(seed) {
    this.seed = seed;
    this[_a] = RandomTypeId;
    this.PRNG = new DeterministicRandom.PCGRandom(seed);
  }
  next() {
    return core.sync(() => this.PRNG.number());
  }
  nextBoolean() {
    return core.map(this.next(), n => n > 0.5);
  }
  nextInt() {
    return core.sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min, max) {
    return core.map(this.next(), n => (max - min) * n + min);
  }
  nextIntBetween(min, max) {
    return core.sync(() => this.PRNG.integer(max - min) + min);
  }
  shuffle(elements) {
    return shuffleWith(elements, n => this.nextIntBetween(0, n + 1));
  }
}
_a = RandomTypeId;
const shuffleWith = (elements, nextIntBounded) => {
  return core.suspend(() => core.flatMap(buffer => {
    const numbers = [];
    for (let i = buffer.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return core.as(Chunk.fromIterable(buffer))(core.forEachSequentialDiscard(n => core.map(k => swap(buffer, n - 1, k))(nextIntBounded(n)))(numbers));
  })(core.sync(() => Array.from(elements))));
};
const swap = (buffer, index1, index2) => {
  const tmp = buffer[index1];
  buffer[index1] = buffer[index2];
  buffer[index2] = tmp;
  return buffer;
};
export const make = seed => new RandomImpl(seed);
//# sourceMappingURL=random.mjs.map