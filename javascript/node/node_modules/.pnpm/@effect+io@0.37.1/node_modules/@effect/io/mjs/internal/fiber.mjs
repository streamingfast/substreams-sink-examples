import * as Either from "@effect/data/Either";
import { dual } from "@effect/data/Function";
import * as HashSet from "@effect/data/HashSet";
import * as number from "@effect/data/Number";
import * as Option from "@effect/data/Option";
import * as order from "@effect/data/Order";
import { pipeArguments } from "@effect/data/Pipeable";
import * as Clock from "@effect/io/Clock";
import * as Exit from "@effect/io/Exit";
import * as FiberId from "@effect/io/Fiber/Id";
import * as FiberStatus from "@effect/io/Fiber/Status";
import * as core from "@effect/io/internal/core";
import * as fiberScope from "@effect/io/internal/fiberScope";
import * as runtimeFlags from "@effect/io/internal/runtimeFlags";
/** @internal */
const FiberSymbolKey = "@effect/io/Fiber";
/** @internal */
export const FiberTypeId = /*#__PURE__*/Symbol.for(FiberSymbolKey);
/** @internal */
export const fiberVariance = {
  _E: _ => _,
  _A: _ => _
};
/** @internal */
const fiberProto = {
  [FiberTypeId]: fiberVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/** @internal */
const RuntimeFiberSymbolKey = "@effect/io/Fiber";
/** @internal */
export const RuntimeFiberTypeId = /*#__PURE__*/Symbol.for(RuntimeFiberSymbolKey);
/** @internal */
export const Order = /*#__PURE__*/order.mapInput(fiber => [fiber.id().startTimeMillis, fiber.id().id])( /*#__PURE__*/order.tuple(number.Order, number.Order));
/** @internal */
export const isFiber = u => typeof u === "object" && u != null && FiberTypeId in u;
/** @internal */
export const isRuntimeFiber = self => RuntimeFiberTypeId in self;
/** @internal */
export const _await = self => self.await();
/** @internal */
export const children = self => self.children();
/** @internal */
export const done = exit => ({
  ...fiberProto,
  id: () => FiberId.none,
  await: () => core.succeed(exit),
  children: () => core.succeed([]),
  inheritAll: () => core.unit,
  poll: () => core.succeed(Option.some(exit)),
  interruptAsFork: () => core.unit
});
/** @internal */
export const dump = self => core.map(self.status(), status => ({
  id: self.id(),
  status
}));
/** @internal */
export const dumpAll = fibers => core.forEachSequential(fibers, dump);
/** @internal */
export const fail = error => done(Exit.fail(error));
/** @internal */
export const failCause = cause => done(Exit.failCause(cause));
/** @internal */
export const fromEffect = effect => core.map(core.exit(effect), done);
/** @internal */
export const id = self => self.id();
/** @internal */
export const inheritAll = self => self.inheritAll();
/** @internal */
export const interrupted = fiberId => done(Exit.interrupt(fiberId));
/** @internal */
export const interruptAll = fibers => core.flatMap(core.fiberId, fiberId => interruptAllAs(fiberId)(fibers));
/** @internal */
export const interruptAllAs = /*#__PURE__*/dual(2, (fibers, fiberId) => core.zipRight(core.forEachSequentialDiscard(_await)(fibers))(core.forEachSequentialDiscard(fibers, interruptAsFork(fiberId))));
/** @internal */
export const interruptAsFork = /*#__PURE__*/dual(2, (self, fiberId) => self.interruptAsFork(fiberId));
/** @internal */
export const join = self => core.zipLeft(core.flatten(self.await()), self.inheritAll());
/** @internal */
export const map = /*#__PURE__*/dual(2, (self, f) => mapEffect(self, a => core.sync(() => f(a))));
/** @internal */
export const mapEffect = /*#__PURE__*/dual(2, (self, f) => ({
  ...fiberProto,
  id: () => self.id(),
  await: () => core.flatMap(self.await(), Exit.forEachEffect(f)),
  children: () => self.children(),
  inheritAll: () => self.inheritAll(),
  poll: () => core.flatMap(self.poll(), result => {
    switch (result._tag) {
      case "None":
        {
          return core.succeed(Option.none());
        }
      case "Some":
        {
          return core.map(Option.some)(Exit.forEachEffect(result.value, f));
        }
    }
  }),
  interruptAsFork: id => self.interruptAsFork(id)
}));
/** @internal */
export const mapFiber = /*#__PURE__*/dual(2, (self, f) => core.map(self.await(), Exit.match({
  onFailure: cause => failCause(cause),
  onSuccess: a => f(a)
})));
/** @internal */
export const match = /*#__PURE__*/dual(2, (self, {
  onFiber,
  onRuntimeFiber
}) => {
  if (isRuntimeFiber(self)) {
    return onRuntimeFiber(self);
  }
  return onFiber(self);
});
/** @internal */
export const never = {
  ...fiberProto,
  id: () => FiberId.none,
  await: () => core.never,
  children: () => core.succeed([]),
  inheritAll: () => core.never,
  poll: () => core.succeed(Option.none()),
  interruptAsFork: () => core.never
};
/** @internal */
export const orElse = /*#__PURE__*/dual(2, (self, that) => ({
  ...fiberProto,
  id: () => FiberId.getOrElse(self.id(), that.id()),
  await: () => core.zipWith(self.await(), that.await(), (exit1, exit2) => Exit.isSuccess(exit1) ? exit1 : exit2),
  children: () => self.children(),
  inheritAll: () => core.zipRight(that.inheritAll(), self.inheritAll()),
  poll: () => core.zipWith(self.poll(), that.poll(), (option1, option2) => {
    switch (option1._tag) {
      case "None":
        {
          return Option.none();
        }
      case "Some":
        {
          return Exit.isSuccess(option1.value) ? option1 : option2;
        }
    }
  }),
  interruptAsFork: id => core.asUnit(core.zipRight(core.interruptAsFiber(id)(that))(core.interruptAsFiber(self, id)))
}));
/** @internal */
export const orElseEither = /*#__PURE__*/dual(2, (self, that) => orElse(map(self, Either.left), map(that, Either.right)));
/** @internal */
export const poll = self => self.poll();
// forked from https://github.com/sindresorhus/parse-ms/blob/4da2ffbdba02c6e288c08236695bdece0adca173/index.js
// MIT License
// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
/** @internal */
const parseMs = milliseconds => {
  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
  return {
    days: roundTowardsZero(milliseconds / 86400000),
    hours: roundTowardsZero(milliseconds / 3600000) % 24,
    minutes: roundTowardsZero(milliseconds / 60000) % 60,
    seconds: roundTowardsZero(milliseconds / 1000) % 60,
    milliseconds: roundTowardsZero(milliseconds) % 1000,
    microseconds: roundTowardsZero(milliseconds * 1000) % 1000,
    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1000
  };
};
/** @internal */
const renderStatus = status => {
  if (FiberStatus.isDone(status)) {
    return "Done";
  }
  if (FiberStatus.isRunning(status)) {
    return "Running";
  }
  const isInterruptible = runtimeFlags.interruptible(status.runtimeFlags) ? "interruptible" : "uninterruptible";
  return `Suspended(${isInterruptible})`;
};
/** @internal */
export const pretty = self => core.flatMap(Clock.currentTimeMillis, now => core.map(dump(self), dump => {
  const time = now - dump.id.startTimeMillis;
  const {
    days,
    hours,
    milliseconds,
    minutes,
    seconds
  } = parseMs(time);
  const lifeMsg = (days === 0 ? "" : `${days}d`) + (days === 0 && hours === 0 ? "" : `${hours}h`) + (days === 0 && hours === 0 && minutes === 0 ? "" : `${minutes}m`) + (days === 0 && hours === 0 && minutes === 0 && seconds === 0 ? "" : `${seconds}s`) + `${milliseconds}ms`;
  const waitMsg = FiberStatus.isSuspended(dump.status) ? (() => {
    const ids = FiberId.ids(dump.status.blockingOn);
    return HashSet.size(ids) > 0 ? `waiting on ` + Array.from(ids).map(id => `${id}`).join(", ") : "";
  })() : "";
  const statusMsg = renderStatus(dump.status);
  return `[Fiber](#${dump.id.id}) (${lifeMsg}) ${waitMsg}\n   Status: ${statusMsg}`;
}));
/** @internal */
export const unsafeRoots = () => Array.from(fiberScope.globalScope.roots);
/** @internal */
export const roots = /*#__PURE__*/core.sync(unsafeRoots);
/** @internal */
export const status = self => self.status();
/** @internal */
export const succeed = value => done(Exit.succeed(value));
/** @internal */
export const unit = /*#__PURE__*/succeed(void 0);
/** @internal */
export const currentFiberURI = "@effect/io/Fiber/Current";
/** @internal */
export const getCurrentFiber = () => Option.fromNullable(globalThis[currentFiberURI]);
//# sourceMappingURL=fiber.mjs.map