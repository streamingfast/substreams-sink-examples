import * as Chunk from "@effect/data/Chunk";
import { dual } from "@effect/data/Function";
import * as RA from "@effect/data/ReadonlyArray";
import * as Cause from "@effect/io/Cause";
import * as Effect from "@effect/io/Effect";
import * as core from "@effect/io/internal/core";
import { invokeWithInterrupt, zipWithOptions } from "@effect/io/internal/fiberRuntime";
import { complete } from "@effect/io/internal/request";
/** @internal */
export const make = runAll => new core.RequestResolverImpl(requests => runAll(requests.map(_ => _.map(_ => _.request))));
/** @internal */
export const makeWithEntry = runAll => new core.RequestResolverImpl(requests => runAll(requests));
/** @internal */
export const makeBatched = run => new core.RequestResolverImpl(requests => requests.length > 1 ? core.forEachSequentialDiscard(requests, block => invokeWithInterrupt(run(block.filter(_ => !_.state.completed).map(_ => _.request)), block)) : requests.length === 1 ? run(requests[0].filter(_ => !_.state.completed).map(_ => _.request)) : core.unit);
/** @internal */
export const around = /*#__PURE__*/dual(3, (self, before, after) => new core.RequestResolverImpl(requests => core.acquireUseRelease(before, () => self.runAll(requests), after), Chunk.make("Around", self, before, after)));
/** @internal */
export const batchN = /*#__PURE__*/dual(2, (self, n) => new core.RequestResolverImpl(requests => {
  return n < 1 ? core.die(Cause.IllegalArgumentException("RequestResolver.batchN: n must be at least 1")) : self.runAll(Array.from(Chunk.map(RA.reduce(requests, Chunk.empty(), (acc, chunk) => Chunk.appendAll(acc, Chunk.chunksOf(Chunk.unsafeFromArray(chunk), n))), chunk => Array.from(chunk))));
}, Chunk.make("BatchN", self, n)));
/** @internal */
export const mapInputContext = /*#__PURE__*/dual(2, (self, f) => new core.RequestResolverImpl(requests => core.mapInputContext(self.runAll(requests), context => f(context)), Chunk.make("MapInputContext", self, f)));
/** @internal */
export const eitherWith = /*#__PURE__*/dual(3, (self, that, f) => new core.RequestResolverImpl(batch => core.forEachSequential(batch, requests => {
  const [as, bs] = RA.partitionMap(f)(requests);
  return zipWithOptions(self.runAll(Array.of(as)), that.runAll(Array.of(bs)), () => void 0, {
    concurrent: true
  });
}), Chunk.make("EitherWith", self, that, f)));
/** @internal */
export const fromFunction = f => makeBatched(requests => core.forEachSequentialDiscard(requests, request => complete(request, core.exitSucceed(f(request))))).identified("FromFunction", f);
/** @internal */
export const fromFunctionBatched = f => makeBatched(as => Effect.forEach(f(as), (res, i) => complete(as[i], core.exitSucceed(res)), {
  discard: true
})).identified("FromFunctionBatched", f);
/** @internal */
export const fromFunctionEffect = f => makeBatched(requests => Effect.forEach(requests, a => Effect.flatMap(Effect.exit(f(a)), e => complete(a, e)), {
  concurrency: "unbounded",
  discard: true
})).identified("FromFunctionEffect", f);
/** @internal */
export const never = /*#__PURE__*/make(() => Effect.never).identified("Never");
/** @internal */
export const provideContext = /*#__PURE__*/dual(2, (self, context) => mapInputContext(self, _ => context).identified("ProvideContext", self, context));
/** @internal */
export const race = /*#__PURE__*/dual(2, (self, that) => new core.RequestResolverImpl(requests => Effect.race(self.runAll(requests), that.runAll(requests))).identified("Race", self, that));
//# sourceMappingURL=dataSource.mjs.map