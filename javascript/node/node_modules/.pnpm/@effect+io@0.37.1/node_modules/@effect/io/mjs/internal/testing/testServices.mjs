import * as Context from "@effect/data/Context";
import { dual } from "@effect/data/Function";
import * as Effect from "@effect/io/Effect";
import * as core from "@effect/io/internal/core";
import * as defaultServices from "@effect/io/internal/defaultServices";
import * as fiberRuntime from "@effect/io/internal/fiberRuntime";
import * as layer from "@effect/io/internal/layer";
import * as ref from "@effect/io/internal/ref";
import * as Annotations from "@effect/io/internal/testing/annotations";
import * as Live from "@effect/io/internal/testing/live";
import * as Sized from "@effect/io/internal/testing/sized";
import * as TestAnnotationMap from "@effect/io/internal/testing/testAnnotationMap";
import * as TestConfig from "@effect/io/internal/testing/testConfig";
/**
 * The default Effect test services.
 *
 * @internal
 */
export const liveServices = /*#__PURE__*/Context.add(TestConfig.TestConfig, TestConfig.make({
  repeats: 100,
  retries: 100,
  samples: 200,
  shrinks: 1000
}))( /*#__PURE__*/Context.add(Sized.Sized, Sized.make(100))( /*#__PURE__*/Context.add(Live.Live, Live.make(defaultServices.liveServices))( /*#__PURE__*/Context.make(Annotations.Annotations, /*#__PURE__*/Annotations.make( /*#__PURE__*/ref.unsafeMake( /*#__PURE__*/TestAnnotationMap.empty()))))));
/** @internal */
export const currentServices = /*#__PURE__*/core.fiberRefUnsafeMakeContext(liveServices);
/**
 * Retrieves the `Annotations` service for this test.
 *
 * @internal
 */
export const annotations = () => annotationsWith(core.succeed);
/**
 * Retrieves the `Annotations` service for this test and uses it to run the
 * specified workflow.
 *
 * @internal
 */
export const annotationsWith = f => core.fiberRefGetWith(currentServices, services => f(Context.get(services, Annotations.Annotations)));
/**
 * Executes the specified workflow with the specified implementation of the
 * annotations service.
 *
 * @internal
 */
export const withAnnotations = /*#__PURE__*/dual(2, (effect, annotations) => core.fiberRefLocallyWith(currentServices, Context.add(Annotations.Annotations, annotations))(effect));
/**
 * Sets the implementation of the annotations service to the specified value
 * and restores it to its original value when the scope is closed.
 *
 * @internal
 */
export const withAnnotationsScoped = annotations => fiberRuntime.fiberRefLocallyScopedWith(currentServices, Context.add(Annotations.Annotations, annotations));
/**
 * Constructs a new `Annotations` service wrapped in a layer.
 *
 * @internal
 */
export const annotationsLayer = () => layer.scoped(Annotations.Annotations, core.tap(withAnnotationsScoped)(core.map(Annotations.make)(core.sync(() => ref.unsafeMake(TestAnnotationMap.empty())))));
/**
 * Accesses an `Annotations` instance in the context and retrieves the
 * annotation of the specified type, or its default value if there is none.
 *
 * @internal
 */
export const get = key => annotationsWith(annotations => annotations.get(key));
/**
 * Accesses an `Annotations` instance in the context and appends the
 * specified annotation to the annotation map.
 *
 * @internal
 */
export const annotate = (key, value) => annotationsWith(annotations => annotations.annotate(key, value));
/**
 * Returns the set of all fibers in this test.
 *
 * @internal
 */
export const supervisedFibers = () => annotationsWith(annotations => annotations.supervisedFibers());
/**
 * Retrieves the `Live` service for this test.
 *
 * @internal
 */
export const live = () => liveWith(core.succeed);
/**
 * Retrieves the `Live` service for this test and uses it to run the specified
 * workflow.
 *
 * @internal
 */
export const liveWith = f => core.fiberRefGetWith(currentServices, services => f(Context.get(services, Live.Live)));
/**
 * Executes the specified workflow with the specified implementation of the
 * live service.
 *
 * @internal
 */
export const withLive = /*#__PURE__*/dual(2, (effect, live) => core.fiberRefLocallyWith(currentServices, Context.add(Live.Live, live))(effect));
/**
 * Sets the implementation of the live service to the specified value and
 * restores it to its original value when the scope is closed.
 *
 * @internal
 */
export const withLiveScoped = live => fiberRuntime.fiberRefLocallyScopedWith(currentServices, Context.add(Live.Live, live));
/**
 * Constructs a new `Live` service wrapped in a layer.
 *
 * @internal
 */
export const liveLayer = () => layer.scoped(Live.Live, core.tap(withLiveScoped)(core.map(Live.make)(core.context())));
/**
 * Provides a workflow with the "live" default Effect services.
 *
 * @internal
 */
export const provideLive = effect => liveWith(live => live.provide(effect));
/**
 * Runs a transformation function with the live default Effect services while
 * ensuring that the workflow itself is run with the test services.
 *
 * @internal
 */
export const provideWithLive = /*#__PURE__*/dual(2, (self, f) => core.fiberRefGetWith(defaultServices.currentServices, services => provideLive(f(core.fiberRefLocally(defaultServices.currentServices, services)(self)))));
/**
 * Retrieves the `Sized` service for this test.
 *
 * @internal
 */
export const sized = () => sizedWith(core.succeed);
/**
 * Retrieves the `Sized` service for this test and uses it to run the
 * specified workflow.
 *
 * @internal
 */
export const sizedWith = f => core.fiberRefGetWith(currentServices, services => f(Context.get(services, Sized.Sized)));
/**
 * Executes the specified workflow with the specified implementation of the
 * sized service.
 *
 * @internal
 */
export const withSized = /*#__PURE__*/dual(2, (effect, sized) => core.fiberRefLocallyWith(currentServices, Context.add(Sized.Sized, sized))(effect));
/**
 * Sets the implementation of the sized service to the specified value and
 * restores it to its original value when the scope is closed.
 *
 * @internal
 */
export const withSizedScoped = sized => fiberRuntime.fiberRefLocallyScopedWith(currentServices, Context.add(Sized.Sized, sized));
/** @internal */
export const sizedLayer = size => layer.scoped(Sized.Sized, core.tap(withSizedScoped)(core.map(Sized.fromFiberRef)(fiberRuntime.fiberRefMake(size))));
/** @internal */
export const size = () => sizedWith(sized => sized.size());
/** @internal */
export const withSize = /*#__PURE__*/dual(2, (effect, size) => sizedWith(sized => sized.withSize(size)(effect)));
/**
 * Retrieves the `TestConfig` service for this test.
 *
 * @internal
 */
export const testConfig = () => testConfigWith(core.succeed);
/**
 * Retrieves the `TestConfig` service for this test and uses it to run the
 * specified workflow.
 *
 * @internal
 */
export const testConfigWith = f => core.fiberRefGetWith(currentServices, services => f(Context.get(services, TestConfig.TestConfig)));
/**
 * Executes the specified workflow with the specified implementation of the
 * config service.
 *
 * @internal
 */
export const withTestConfig = /*#__PURE__*/dual(2, (effect, config) => core.fiberRefLocallyWith(currentServices, Context.add(TestConfig.TestConfig, config))(effect));
/**
 * Sets the implementation of the config service to the specified value and
 * restores it to its original value when the scope is closed.
 *
 * @internal
 */
export const withTestConfigScoped = config => fiberRuntime.fiberRefLocallyScopedWith(currentServices, Context.add(TestConfig.TestConfig, config));
/**
 * Constructs a new `TestConfig` service with the specified settings.
 *
 * @internal
 */
export const testConfigLayer = params => layer.scoped(TestConfig.TestConfig, Effect.suspend(() => {
  const testConfig = TestConfig.make(params);
  return core.as(testConfig)(withTestConfigScoped(testConfig));
}));
/**
 * The number of times to repeat tests to ensure they are stable.
 *
 * @internal
 */
export const repeats = () => testConfigWith(config => core.succeed(config.repeats));
/**
 * The number of times to retry flaky tests.
 *
 * @internal
 */
export const retries = () => testConfigWith(config => core.succeed(config.retries));
/**
 * The number of sufficient samples to check for a random variable.
 *
 * @internal
 */
export const samples = () => testConfigWith(config => core.succeed(config.samples));
/**
 * The maximum number of shrinkings to minimize large failures.
 *
 * @internal
 */
export const shrinks = () => testConfigWith(config => core.succeed(config.shrinks));
//# sourceMappingURL=testServices.mjs.map