var _a, _b, _c, _d, _e;
import * as Chunk from "@effect/data/Chunk";
import { dual } from "@effect/data/Function";
import * as MutableQueue from "@effect/data/MutableQueue";
import * as MutableRef from "@effect/data/MutableRef";
import { pipeArguments } from "@effect/data/Pipeable";
import * as ReadonlyArray from "@effect/data/ReadonlyArray";
import * as core from "@effect/io/internal/core";
import * as fiberRuntime from "@effect/io/internal/fiberRuntime";
/** @internal */
const EnqueueSymbolKey = "@effect/io/Queue/Enqueue";
/** @internal */
export const EnqueueTypeId = /*#__PURE__*/Symbol.for(EnqueueSymbolKey);
/** @internal */
const DequeueSymbolKey = "@effect/io/Queue/Dequeue";
/** @internal */
export const DequeueTypeId = /*#__PURE__*/Symbol.for(DequeueSymbolKey);
/** @internal */
const QueueStrategySymbolKey = "@effect/io/Queue/Strategy";
/** @internal */
export const QueueStrategyTypeId = /*#__PURE__*/Symbol.for(QueueStrategySymbolKey);
/** @internal */
const queueStrategyVariance = {
  _A: _ => _
};
/** @internal */
export const enqueueVariance = {
  _In: _ => _
};
/** @internal */
export const dequeueVariance = {
  _Out: _ => _
};
/** @internal */
class QueueImpl {
  constructor( /** @internal */
  queue, /** @internal */
  takers, /** @internal */
  shutdownHook, /** @internal */
  shutdownFlag, /** @internal */
  strategy) {
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this[_a] = enqueueVariance;
    this[_b] = dequeueVariance;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  capacity() {
    return MutableQueue.capacity(this.queue);
  }
  size() {
    return core.suspend(() => MutableRef.get(this.shutdownFlag) ? core.interrupt : core.succeed(MutableQueue.length(this.queue) - MutableQueue.length(this.takers) + this.strategy.surplusSize()));
  }
  isEmpty() {
    return core.map(this.size(), size => size <= 0);
  }
  isFull() {
    return core.map(this.size(), size => size >= this.capacity());
  }
  shutdown() {
    return core.uninterruptible(core.withFiberRuntime(state => {
      MutableRef.set(true)(this.shutdownFlag);
      return core.asUnit(core.whenEffect(core.deferredSucceed(this.shutdownHook, void 0))(core.zipRight(this.strategy.shutdown())(fiberRuntime.forEachParUnboundedDiscard(unsafePollAll(this.takers), d => core.deferredInterruptWith(d, state.id()), false))));
    }));
  }
  isShutdown() {
    return core.sync(() => MutableRef.get(this.shutdownFlag));
  }
  awaitShutdown() {
    return core.deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !MutableRef.get(this.shutdownFlag);
  }
  unsafeOffer(value) {
    if (MutableRef.get(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (MutableQueue.isEmpty(this.queue)) {
      const taker = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(this.takers);
      if (taker !== MutableQueue.EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    // Not enough takers, offer to the queue
    const succeeded = MutableQueue.offer(value)(this.queue);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value) {
    return core.suspend(() => {
      if (MutableRef.get(this.shutdownFlag)) {
        return core.interrupt;
      }
      let noRemaining;
      if (MutableQueue.isEmpty(this.queue)) {
        const taker = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(this.takers);
        if (taker !== MutableQueue.EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return core.succeed(true);
      }
      // Not enough takers, offer to the queue
      const succeeded = MutableQueue.offer(value)(this.queue);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? core.succeed(true) : this.strategy.handleSurplus([value], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return core.suspend(() => {
      if (MutableRef.get(this.shutdownFlag)) {
        return core.interrupt;
      }
      const values = ReadonlyArray.fromIterable(iterable);
      const pTakers = MutableQueue.isEmpty(this.queue) ? ReadonlyArray.fromIterable(unsafePollN(this.takers, values.length)) : ReadonlyArray.empty;
      const [forTakers, remaining] = ReadonlyArray.splitAt(pTakers.length)(values);
      for (let i = 0; i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return core.succeed(true);
      }
      // Not enough takers, offer to the queue
      const surplus = unsafeOfferAll(this.queue, remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return Chunk.isEmpty(surplus) ? core.succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  take() {
    return core.withFiberRuntime(state => {
      if (MutableRef.get(this.shutdownFlag)) {
        return core.interrupt;
      }
      const item = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(this.queue);
      if (item !== MutableQueue.EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return core.succeed(item);
      } else {
        // Add the deferred to takers, then:
        // - Try to take again in case a value was added since
        // - Wait for the deferred to be completed
        // - Clean up resources in case of interruption
        const deferred = core.deferredUnsafeMake(state.id());
        return core.onInterrupt(() => {
          return core.sync(() => unsafeRemove(this.takers, deferred));
        })(core.suspend(() => {
          MutableQueue.offer(deferred)(this.takers);
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return MutableRef.get(this.shutdownFlag) ? core.interrupt : core.deferredAwait(deferred);
        }));
      }
    });
  }
  takeAll() {
    return core.suspend(() => {
      return MutableRef.get(this.shutdownFlag) ? core.interrupt : core.sync(() => {
        const values = unsafePollAll(this.queue);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return Chunk.fromIterable(values);
      });
    });
  }
  takeUpTo(max) {
    return core.suspend(() => MutableRef.get(this.shutdownFlag) ? core.interrupt : core.sync(() => {
      const values = unsafePollN(this.queue, max);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return Chunk.fromIterable(values);
    }));
  }
  takeBetween(min, max) {
    return core.suspend(() => takeRemainderLoop(this, min, max, Chunk.empty()));
  }
}
_a = EnqueueTypeId, _b = DequeueTypeId;
/** @internal */
const takeRemainderLoop = (self, min, max, acc) => {
  if (max < min) {
    return core.succeed(acc);
  }
  return core.flatMap(bs => {
    const remaining = min - bs.length;
    if (remaining === 1) {
      return core.map(b => Chunk.append(b)(Chunk.appendAll(bs)(acc)))(take(self));
    }
    if (remaining > 1) {
      return core.flatMap(b => takeRemainderLoop(self, remaining - 1, max - bs.length - 1, Chunk.append(b)(Chunk.appendAll(bs)(acc))))(take(self));
    }
    return core.succeed(Chunk.appendAll(bs)(acc));
  })(takeUpTo(self, max));
};
/** @internal */
export const isQueue = u => isEnqueue(u) && isDequeue(u);
/** @internal */
export const isEnqueue = u => typeof u === "object" && u != null && EnqueueTypeId in u;
/** @internal */
export const isDequeue = u => typeof u === "object" && u != null && DequeueTypeId in u;
/** @internal */
export const bounded = requestedCapacity => core.flatMap(queue => make(queue, backPressureStrategy()))(core.sync(() => MutableQueue.bounded(requestedCapacity)));
/** @internal */
export const dropping = requestedCapacity => core.flatMap(queue => make(queue, droppingStrategy()))(core.sync(() => MutableQueue.bounded(requestedCapacity)));
/** @internal */
export const sliding = requestedCapacity => core.flatMap(queue => make(queue, slidingStrategy()))(core.sync(() => MutableQueue.bounded(requestedCapacity)));
/** @internal */
export const unbounded = () => core.flatMap(queue => make(queue, droppingStrategy()))(core.sync(() => MutableQueue.unbounded()));
/** @internal */
const unsafeMake = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
};
/** @internal */
const make = (queue, strategy) => core.map(deferred => unsafeMake(queue, MutableQueue.unbounded(), deferred, MutableRef.make(false), strategy))(core.deferredMake());
/** @internal */
export const capacity = self => self.capacity();
/** @internal */
export const size = self => self.size();
/** @internal */
export const isFull = self => self.isFull();
/** @internal */
export const isEmpty = self => self.isEmpty();
/** @internal */
export const isShutdown = self => self.isShutdown();
/** @internal */
export const awaitShutdown = self => self.awaitShutdown();
/** @internal */
export const shutdown = self => self.shutdown();
/** @internal */
export const offer = /*#__PURE__*/dual(2, (self, value) => self.offer(value));
/** @internal */
export const unsafeOffer = /*#__PURE__*/dual(2, (self, value) => self.unsafeOffer(value));
/** @internal */
export const offerAll = /*#__PURE__*/dual(2, (self, iterable) => self.offerAll(iterable));
/** @internal */
export const poll = self => core.map(self.takeUpTo(1), Chunk.head);
/** @internal */
export const take = self => self.take();
/** @internal */
export const takeAll = self => self.takeAll();
/** @internal */
export const takeUpTo = /*#__PURE__*/dual(2, (self, max) => self.takeUpTo(max));
/** @internal */
export const takeBetween = /*#__PURE__*/dual(3, (self, min, max) => self.takeBetween(min, max));
/** @internal */
export const takeN = /*#__PURE__*/dual(2, (self, n) => self.takeBetween(n, n));
// -----------------------------------------------------------------------------
// Strategy
// -----------------------------------------------------------------------------
/** @internal */
export const backPressureStrategy = () => new BackPressureStrategy();
/** @internal */
export const droppingStrategy = () => new DroppingStrategy();
/** @internal */
export const slidingStrategy = () => new SlidingStrategy();
/** @internal */
class BackPressureStrategy {
  constructor() {
    this[_c] = queueStrategyVariance;
    this.putters = MutableQueue.unbounded();
  }
  surplusSize() {
    return MutableQueue.length(this.putters);
  }
  shutdown() {
    return core.flatMap(fiberId => core.flatMap(putters => fiberRuntime.forEachParUnboundedDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? core.asUnit(core.deferredInterruptWith(deferred, fiberId)) : core.unit, false))(core.sync(() => unsafePollAll(this.putters))))(core.fiberId);
  }
  handleSurplus(iterable, queue, takers, isShutdown) {
    return core.withFiberRuntime(state => {
      const deferred = core.deferredUnsafeMake(state.id());
      return core.onInterrupt(() => core.sync(() => this.unsafeRemove(deferred)))(core.suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return MutableRef.get(isShutdown) ? core.interrupt : core.deferredAwait(deferred);
      }));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && !MutableQueue.isFull(queue)) {
      const putter = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(this.putters);
      if (putter === MutableQueue.EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = MutableQueue.offer(putter[0])(queue);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, Chunk.prepend(putter)(unsafePollAll(this.putters)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const iterator = iterable[Symbol.iterator]();
    let next = iterator.next();
    if (!next.done) {
      // eslint-disable-next-line no-constant-condition
      while (1) {
        const value = next.value;
        next = iterator.next();
        if (next.done) {
          MutableQueue.offer([value, deferred, true])(this.putters);
          break;
        }
        MutableQueue.offer([value, deferred, false])(this.putters);
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, Chunk.filter(([, _]) => _ !== deferred)(unsafePollAll(this.putters)));
  }
}
_c = QueueStrategyTypeId;
/** @internal */
class DroppingStrategy {
  constructor() {
    this[_d] = queueStrategyVariance;
  }
  surplusSize() {
    return 0;
  }
  shutdown() {
    return core.unit;
  }
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return core.succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
    //
  }
}
_d = QueueStrategyTypeId;
/** @internal */
class SlidingStrategy {
  constructor() {
    this[_e] = queueStrategyVariance;
  }
  surplusSize() {
    return 0;
  }
  shutdown() {
    return core.unit;
  }
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return core.sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
    //
  }
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next;
    let offering = true;
    while (!(next = iterator.next()).done && offering) {
      if (MutableQueue.capacity(queue) === 0) {
        return;
      }
      // Poll 1 and retry
      MutableQueue.poll(MutableQueue.EmptyMutableQueue)(queue);
      offering = MutableQueue.offer(next.value)(queue);
    }
  }
}
_e = QueueStrategyTypeId;
/** @internal */
const unsafeCompleteDeferred = (deferred, a) => {
  return core.deferredUnsafeDone(deferred, core.succeed(a));
};
/** @internal */
const unsafeOfferAll = (queue, as) => {
  return MutableQueue.offerAll(as)(queue);
};
/** @internal */
const unsafePollAll = queue => {
  return MutableQueue.pollUpTo(Number.POSITIVE_INFINITY)(queue);
};
/** @internal */
const unsafePollN = (queue, max) => {
  return MutableQueue.pollUpTo(max)(queue);
};
/** @internal */
export const unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, Chunk.filter(b => a !== b)(unsafePollAll(queue)));
};
/** @internal */
export const unsafeCompleteTakers = (strategy, queue, takers) => {
  // Check both a taker and an item are in the queue, starting with the taker
  let keepPolling = true;
  while (keepPolling && !MutableQueue.isEmpty(queue)) {
    const taker = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(takers);
    if (taker !== MutableQueue.EmptyMutableQueue) {
      const element = MutableQueue.poll(MutableQueue.EmptyMutableQueue)(queue);
      if (element !== MutableQueue.EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, Chunk.prepend(taker)(unsafePollAll(takers)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
};
//# sourceMappingURL=queue.mjs.map