var _a;
import * as Chunk from "@effect/data/Chunk";
import * as Equal from "@effect/data/Equal";
import * as Hash from "@effect/data/Hash";
import { pipeArguments } from "@effect/data/Pipeable";
import * as ReadonlyArray from "@effect/data/ReadonlyArray";
/** @internal */
const MetricBoundariesSymbolKey = "@effect/io/Metric/Boundaries";
/** @internal */
export const MetricBoundariesTypeId = /*#__PURE__*/Symbol.for(MetricBoundariesSymbolKey);
/** @internal */
class MetricBoundariesImpl {
  constructor(values) {
    this.values = values;
    this[_a] = MetricBoundariesTypeId;
  }
  [(_a = MetricBoundariesTypeId, Hash.symbol)]() {
    return Hash.combine(Hash.hash(this.values))(Hash.hash(MetricBoundariesSymbolKey));
  }
  [Equal.symbol](u) {
    return isMetricBoundaries(u) && Equal.equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
/** @internal */
export const isMetricBoundaries = u => {
  return typeof u === "object" && u != null && MetricBoundariesTypeId in u;
};
/** @internal */
export const fromChunk = chunk => {
  const values = Chunk.dedupe(Chunk.appendAll(Chunk.of(Number.POSITIVE_INFINITY))(chunk));
  return new MetricBoundariesImpl(values);
};
/** @internal */
export const linear = options => fromChunk(Chunk.unsafeFromArray(ReadonlyArray.makeBy(options.count - 1, i => options.start + i * options.width)));
/** @internal */
export const exponential = options => fromChunk(Chunk.unsafeFromArray(ReadonlyArray.makeBy(options.count - 1, i => options.start * Math.pow(options.factor, i))));
//# sourceMappingURL=boundaries.mjs.map