"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prettyErrors = exports.pretty = void 0;
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var internal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/internal/cause"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// -----------------------------------------------------------------------------
// Pretty Printing
// -----------------------------------------------------------------------------
/** @internal */
const renderToString = u => {
  if (typeof u === "object" && u != null && "toString" in u && typeof u["toString"] === "function" && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  if (typeof u === "string") {
    return `Error: ${u}`;
  }
  if (typeof u === "object" && u !== null) {
    if ("message" in u && typeof u["message"] === "string") {
      const raw = JSON.parse(JSON.stringify(u));
      const keys = new Set(Object.keys(raw));
      keys.delete("name");
      keys.delete("message");
      keys.delete("_tag");
      if (keys.size === 0) {
        return `${"name" in u && typeof u.name === "string" ? u.name : "Error"}${"_tag" in u && typeof u["_tag"] === "string" ? `(${u._tag})` : ``}: ${u.message}`;
      }
    }
  }
  return `Error: ${JSON.stringify(u)}`;
};
/** @internal */
const defaultErrorToLines = error => {
  if (error instanceof Error) {
    return [renderToString(error), error.stack?.split("\n").filter(_ => !_.startsWith("Error")).join("\n")];
  }
  return [renderToString(error), void 0];
};
class RenderError {
  constructor(message, stack, span) {
    this.message = message;
    this.stack = stack;
    this.span = span;
  }
}
const filterStack = stack => {
  const lines = stack.split("\n");
  const out = [];
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].includes("EffectPrimitive") || lines[i].includes("Generator.next") || lines[i].includes("FiberRuntime")) {
      return out.join("\n");
    } else {
      out.push(lines[i]);
    }
  }
  return out.join("\n");
};
/** @internal */
const pretty = cause => {
  if (internal.isInterruptedOnly(cause)) {
    return "All fibers interrupted without errors.";
  }
  const final = prettyErrors(cause).map(e => {
    let message = e.message;
    if (e.stack) {
      message += `\r\n${filterStack(e.stack)}`;
    }
    if (e.span) {
      let current = e.span;
      let i = 0;
      while (current && current._tag === "Span" && i < 10) {
        message += `\r\n    at ${current.name}`;
        current = Option.getOrUndefined(current.parent);
        i++;
      }
    }
    return message;
  }).join("\r\n\r\n");
  if (!final.includes("\r\n")) {
    return final;
  }
  return `\r\n${final}\r\n`;
};
/** @internal */
exports.pretty = pretty;
const prettyErrors = cause => internal.reduceWithContext(cause, void 0, {
  emptyCase: () => [],
  dieCase: (_, err) => {
    const rendered = defaultErrorToLines(err);
    return [{
      message: rendered[0],
      stack: rendered[1],
      span: undefined
    }];
  },
  failCase: (_, err) => {
    const rendered = defaultErrorToLines(err);
    return [{
      message: rendered[0],
      stack: rendered[1],
      span: undefined
    }];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r],
  annotatedCase: (_, v, annotation) => internal.isSpanAnnotation(annotation) ? v.map(error => ({
    ...error,
    span: error.span ?? annotation.span
  })) : v
});
exports.prettyErrors = prettyErrors;
//# sourceMappingURL=cause-pretty.js.map