var _a;
import * as Context from "@effect/data/Context";
import * as Duration from "@effect/data/Duration";
import * as Equal from "@effect/data/Equal";
import { dual } from "@effect/data/Function";
import * as Hash from "@effect/data/Hash";
import * as HashSet from "@effect/data/HashSet";
import { pipeArguments } from "@effect/data/Pipeable";
import * as core from "@effect/io/internal/core";
import * as effect from "@effect/io/internal/effect";
import * as fiberRuntime from "@effect/io/internal/fiberRuntime";
import * as queue from "@effect/io/internal/queue";
import * as ref from "@effect/io/internal/ref";
/** @internal */
const PoolSymbolKey = "@effect/io/Pool";
/** @internal */
export const PoolTypeId = /*#__PURE__*/Symbol.for(PoolSymbolKey);
const poolVariance = {
  _E: _ => _,
  _A: _ => _
};
/**
 * A strategy that does nothing to shrink excess items. This is useful when
 * the minimum size of the pool is equal to its maximum size and so there is
 * nothing to do.
 */
class NoneStrategy {
  initial() {
    return core.unit;
  }
  track() {
    return core.unit;
  }
  run() {
    return core.unit;
  }
}
/**
 * A strategy that shrinks the pool down to its minimum size if items in the
 * pool have not been used for the specified duration.
 */
class TimeToLiveStrategy {
  constructor(timeToLive) {
    this.timeToLive = timeToLive;
  }
  initial() {
    return core.flatMap(effect.clock, clock => core.flatMap(clock.currentTimeMillis, now => core.map(ref.make(now), ref => [clock, ref])));
  }
  track(state) {
    return core.asUnit(core.flatMap(state[0].currentTimeMillis, now => ref.set(state[1], now)));
  }
  run(state, getExcess, shrink) {
    return core.flatMap(getExcess, excess => excess <= 0 ? core.zipRight(state[0].sleep(this.timeToLive), this.run(state, getExcess, shrink)) : core.flatMap(duration => {
      if (duration >= Duration.toMillis(this.timeToLive)) {
        return core.zipRight(shrink, this.run(state, getExcess, shrink));
      } else {
        return core.zipRight(state[0].sleep(this.timeToLive), this.run(state, getExcess, shrink));
      }
    })(core.zipWith(ref.get(state[1]), state[0].currentTimeMillis, (start, end) => end - start)));
  }
}
class PoolImpl {
  constructor(creator, min, max, isShuttingDown, state, items, invalidated, track) {
    this.creator = creator;
    this.min = min;
    this.max = max;
    this.isShuttingDown = isShuttingDown;
    this.state = state;
    this.items = items;
    this.invalidated = invalidated;
    this.track = track;
    this[_a] = poolVariance;
  }
  [(_a = PoolTypeId, Hash.symbol)]() {
    return Hash.combine(Hash.hash(this.track))(Hash.combine(Hash.hash(this.invalidated))(Hash.combine(Hash.hash(this.items))(Hash.combine(Hash.hash(this.state))(Hash.combine(Hash.hash(this.isShuttingDown))(Hash.combine(Hash.number(this.max))(Hash.combine(Hash.number(this.min))(Hash.hash(this.creator))))))));
  }
  [Equal.symbol](that) {
    return isPool(that) && Equal.equals(this.creator, that.creator) && this.min === that.min && this.max === that.max && Equal.equals(this.isShuttingDown, that.isShuttingDown) && Equal.equals(this.state, that.state) && Equal.equals(this.items, that.items) && Equal.equals(this.invalidated, that.invalidated) && Equal.equals(this.track, that.track);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get() {
    const acquire = () => core.flatMap(ref.get(this.isShuttingDown), down => down ? core.interrupt : core.flatten(ref.modify(this.state, state => {
      if (state.free > 0 || state.size >= this.max) {
        return [core.flatMap(queue.take(this.items), attempted => core.exitMatch(attempted.result, {
          onFailure: () => core.succeed(attempted),
          onSuccess: item => core.flatMap(ref.get(this.invalidated), set => {
            if (HashSet.has(item)(set)) {
              return core.flatMap(finalizeInvalid(this, attempted), acquire);
            }
            return core.succeed(attempted);
          })
        })), {
          ...state,
          free: state.free - 1
        }];
      }
      if (state.size >= 0) {
        return [core.flatMap(allocate(this), acquire), {
          size: state.size + 1,
          free: state.free + 1
        }];
      }
      return [core.interrupt, state];
    })));
    const release = attempted => core.exitMatch(attempted.result, {
      onFailure: () => core.flatten(ref.modify(this.state, state => {
        if (state.size <= this.min) {
          return [allocate(this), {
            ...state,
            free: state.free + 1
          }];
        }
        return [core.unit, {
          ...state,
          size: state.size - 1
        }];
      })),
      onSuccess: item => core.flatMap(ref.get(this.invalidated), set => {
        if (HashSet.has(item)(set)) {
          return finalizeInvalid(this, attempted);
        }
        return core.zipRight(core.whenEffect(getAndShutdown(this), ref.get(this.isShuttingDown)))(core.zipRight(this.track(attempted.result))(core.zipRight(queue.offer(this.items, attempted))(ref.update(this.state, state => ({
          ...state,
          free: state.free + 1
        })))));
      })
    });
    return core.flatMap(([release, attempted]) => core.zipRight(toEffect(attempted))(effect.when(release, () => isFailure(attempted))))(fiberRuntime.disconnect(fiberRuntime.withEarlyRelease(fiberRuntime.acquireRelease(acquire(), release))));
  }
  invalidate(item) {
    return ref.update(this.invalidated, HashSet.add(item));
  }
}
const allocate = self => core.uninterruptibleMask(restore => core.flatMap(fiberRuntime.scopeMake(), scope => core.flatMap(core.exit(restore(fiberRuntime.scopeExtend(self.creator, scope))), exit => core.flatMap(core.succeed({
  result: exit,
  finalizer: core.scopeClose(scope, core.exitSucceed(void 0))
}), attempted => core.as(attempted)(core.zipRight(core.whenEffect(getAndShutdown(self), ref.get(self.isShuttingDown)))(core.zipRight(self.track(attempted.result))(queue.offer(self.items, attempted))))))));
/**
 * Returns the number of items in the pool in excess of the minimum size.
 */
const excess = self => core.map(ref.get(self.state), state => state.size - Math.min(self.min, state.free));
const finalizeInvalid = (self, attempted) => core.zipRight(core.flatten(ref.modify(self.state, state => {
  if (state.size <= self.min) {
    return [allocate(self), {
      ...state,
      free: state.free + 1
    }];
  }
  return [core.unit, {
    ...state,
    size: state.size - 1
  }];
})))(core.zipRight(attempted.finalizer)(forEach(attempted, a => ref.update(self.invalidated, HashSet.remove(a)))));
/**
 * Gets items from the pool and shuts them down as long as there are items
 * free, signalling shutdown of the pool if the pool is empty.
 */
const getAndShutdown = self => core.flatten(ref.modify(self.state, state => {
  if (state.free > 0) {
    return [core.matchCauseEffect(queue.take(self.items), {
      onFailure: () => core.unit,
      onSuccess: attempted => core.flatMap(() => getAndShutdown(self))(core.zipRight(ref.update(self.state, state => ({
        ...state,
        size: state.size - 1
      })))(core.zipRight(attempted.finalizer)(forEach(attempted, a => ref.update(self.invalidated, HashSet.remove(a))))))
    }), {
      ...state,
      free: state.free - 1
    }];
  }
  if (state.size > 0) {
    return [core.unit, state];
  }
  return [queue.shutdown(self.items), {
    ...state,
    size: state.size - 1
  }];
}));
/**
 * Begins pre-allocating pool entries based on minimum pool size.
 */
const initialize = self => fiberRuntime.replicateEffect(core.uninterruptibleMask(restore => core.flatten(ref.modify(self.state, state => {
  if (state.size < self.min && state.size >= 0) {
    return [core.flatMap(fiberRuntime.scopeMake(), scope => core.flatMap(core.exit(restore(fiberRuntime.scopeExtend(self.creator, scope))), exit => core.flatMap(core.succeed({
      result: exit,
      finalizer: core.scopeClose(scope, core.exitSucceed(void 0))
    }), attempted => core.as(attempted)(core.zipRight(core.whenEffect(getAndShutdown(self), ref.get(self.isShuttingDown)))(core.zipRight(self.track(attempted.result))(queue.offer(self.items, attempted))))))), {
      size: state.size + 1,
      free: state.free + 1
    }];
  }
  return [core.unit, state];
}))), self.min, {
  discard: true
});
/**
 * Shrinks the pool down, but never to less than the minimum size.
 */
const shrink = self => core.uninterruptible(core.flatten(ref.modify(self.state, state => {
  if (state.size > self.min && state.free > 0) {
    return [core.flatMap(attempted => core.zipRight(ref.update(self.state, state => ({
      ...state,
      size: state.size - 1
    })))(core.zipRight(attempted.finalizer)(forEach(attempted, a => ref.update(self.invalidated, HashSet.remove(a))))))(queue.take(self.items)), {
      ...state,
      free: state.free - 1
    }];
  }
  return [core.unit, state];
})));
const shutdown = self => core.flatten(ref.modify(self.isShuttingDown, down => down ? [queue.awaitShutdown(self.items), true] : [core.zipRight(getAndShutdown(self), queue.awaitShutdown(self.items)), true]));
const isFailure = self => core.exitIsFailure(self.result);
const forEach = (self, f) => core.exitMatch(self.result, {
  onFailure: () => core.unit,
  onSuccess: f
});
const toEffect = self => self.result;
/**
 * A more powerful variant of `make` that allows specifying a `Strategy` that
 * describes how a pool whose excess items are not being used will be shrunk
 * down to the minimum size.
 */
const makeWith = options => core.uninterruptibleMask(restore => core.flatMap(([context, down, state, items, inv, initial]) => {
  const pool = new PoolImpl(core.mapInputContext(options.acquire, old => Context.merge(old)(context)), options.min, options.max, down, state, items, inv, exit => options.strategy.track(initial, exit));
  return core.as(pool)(core.flatMap(fiber => core.flatMap(fiberRuntime.forkDaemon(restore(options.strategy.run(initial, excess(pool), shrink(pool)))), shrink => fiberRuntime.addFinalizer(() => core.zipRight(core.interruptFiber(shrink))(core.zipRight(core.interruptFiber(fiber))(shutdown(pool))))))(fiberRuntime.forkDaemon(restore(initialize(pool)))));
})(fiberRuntime.all([core.context(), ref.make(false), ref.make({
  size: 0,
  free: 0
}), queue.bounded(options.max), ref.make(HashSet.empty()), options.strategy.initial()])));
/** @internal */
export const isPool = u => typeof u === "object" && u != null && PoolTypeId in u;
/** @internal */
export const make = options => makeWith({
  acquire: options.acquire,
  min: options.size,
  max: options.size,
  strategy: new NoneStrategy()
});
/** @internal */
export const makeWithTTL = options => makeWith({
  acquire: options.acquire,
  min: options.min,
  max: options.max,
  strategy: new TimeToLiveStrategy(Duration.decode(options.timeToLive))
});
/** @internal */
export const get = self => self.get();
/** @internal */
export const invalidate = /*#__PURE__*/dual(2, (self, value) => self.invalidate(value));
//# sourceMappingURL=pool.mjs.map