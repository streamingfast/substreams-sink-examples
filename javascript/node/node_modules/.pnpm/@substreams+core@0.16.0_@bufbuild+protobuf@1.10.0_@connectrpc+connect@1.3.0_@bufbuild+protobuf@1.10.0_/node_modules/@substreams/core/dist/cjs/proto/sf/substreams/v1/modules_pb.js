"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Modules = exports.Module_Output = exports.Module_KindStore_UpdatePolicy = exports.Module_KindStore = exports.Module_KindMap = exports.Module_Input_Store_Mode = exports.Module_Input_Store = exports.Module_Input_Source = exports.Module_Input_Params = exports.Module_Input_Map = exports.Module_Input = exports.Module = exports.Binary = void 0;
var _protobuf = /*#__PURE__*/require("@bufbuild/protobuf");
// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file sf/substreams/v1/modules.proto (package sf.substreams.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

/**
 * @generated from message sf.substreams.v1.Modules
 */
class Modules extends _protobuf.Message {
  /**
   * @generated from field: repeated sf.substreams.v1.Module modules = 1;
   */
  modules = [];
  /**
   * @generated from field: repeated sf.substreams.v1.Binary binaries = 2;
   */
  binaries = [];
  constructor(data) {
    super();
    _protobuf.proto3.util.initPartial(data, this);
  }
  static runtime = _protobuf.proto3;
  static typeName = "sf.substreams.v1.Modules";
  static fields = _protobuf.proto3.util.newFieldList(() => [{
    no: 1,
    name: "modules",
    kind: "message",
    T: Module,
    repeated: true
  }, {
    no: 2,
    name: "binaries",
    kind: "message",
    T: Binary,
    repeated: true
  }]);
  static fromBinary(bytes, options) {
    return new Modules().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new Modules().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Modules().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return _protobuf.proto3.util.equals(Modules, a, b);
  }
}
/**
 * Binary represents some code compiled to its binary form.
 *
 * @generated from message sf.substreams.v1.Binary
 */
exports.Modules = Modules;
class Binary extends _protobuf.Message {
  /**
   * @generated from field: string type = 1;
   */
  type = "";
  /**
   * @generated from field: bytes content = 2;
   */
  content = new Uint8Array(0);
  constructor(data) {
    super();
    _protobuf.proto3.util.initPartial(data, this);
  }
  static runtime = _protobuf.proto3;
  static typeName = "sf.substreams.v1.Binary";
  static fields = _protobuf.proto3.util.newFieldList(() => [{
    no: 1,
    name: "type",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }, {
    no: 2,
    name: "content",
    kind: "scalar",
    T: 12 /* ScalarType.BYTES */
  }]);
  static fromBinary(bytes, options) {
    return new Binary().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new Binary().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Binary().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return _protobuf.proto3.util.equals(Binary, a, b);
  }
}
/**
 * @generated from message sf.substreams.v1.Module
 */
exports.Binary = Binary;
class Module extends _protobuf.Message {
  /**
   * @generated from field: string name = 1;
   */
  name = "";
  /**
   * @generated from oneof sf.substreams.v1.Module.kind
   */
  kind = {
    case: undefined
  };
  /**
   * @generated from field: uint32 binary_index = 4;
   */
  binaryIndex = 0;
  /**
   * @generated from field: string binary_entrypoint = 5;
   */
  binaryEntrypoint = "";
  /**
   * @generated from field: repeated sf.substreams.v1.Module.Input inputs = 6;
   */
  inputs = [];
  /**
   * @generated from field: sf.substreams.v1.Module.Output output = 7;
   */
  output;
  /**
   * @generated from field: uint64 initial_block = 8;
   */
  initialBlock = _protobuf.protoInt64.zero;
  constructor(data) {
    super();
    _protobuf.proto3.util.initPartial(data, this);
  }
  static runtime = _protobuf.proto3;
  static typeName = "sf.substreams.v1.Module";
  static fields = _protobuf.proto3.util.newFieldList(() => [{
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }, {
    no: 2,
    name: "kind_map",
    kind: "message",
    T: Module_KindMap,
    oneof: "kind"
  }, {
    no: 3,
    name: "kind_store",
    kind: "message",
    T: Module_KindStore,
    oneof: "kind"
  }, {
    no: 4,
    name: "binary_index",
    kind: "scalar",
    T: 13 /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "binary_entrypoint",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }, {
    no: 6,
    name: "inputs",
    kind: "message",
    T: Module_Input,
    repeated: true
  }, {
    no: 7,
    name: "output",
    kind: "message",
    T: Module_Output
  }, {
    no: 8,
    name: "initial_block",
    kind: "scalar",
    T: 4 /* ScalarType.UINT64 */
  }]);
  static fromBinary(bytes, options) {
    return new Module().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new Module().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Module().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return _protobuf.proto3.util.equals(Module, a, b);
  }
}
/**
 * @generated from message sf.substreams.v1.Module.KindMap
 */
exports.Module = Module;
class Module_KindMap extends _protobuf.Message {
  /**
   * @generated from field: string output_type = 1;
   */
  outputType = "";
  constructor(data) {
    super();
    _protobuf.proto3.util.initPartial(data, this);
  }
  static runtime = _protobuf.proto3;
  static typeName = "sf.substreams.v1.Module.KindMap";
  static fields = _protobuf.proto3.util.newFieldList(() => [{
    no: 1,
    name: "output_type",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }]);
  static fromBinary(bytes, options) {
    return new Module_KindMap().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new Module_KindMap().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Module_KindMap().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return _protobuf.proto3.util.equals(Module_KindMap, a, b);
  }
}
/**
 * @generated from message sf.substreams.v1.Module.KindStore
 */
exports.Module_KindMap = Module_KindMap;
class Module_KindStore extends _protobuf.Message {
  /**
   * The `update_policy` determines the functions available to mutate the store
   * (like `set()`, `set_if_not_exists()` or `sum()`, etc..) in
   * order to ensure that parallel operations are possible and deterministic
   *
   * Say a store cumulates keys from block 0 to 1M, and a second store
   * cumulates keys from block 1M to 2M. When we want to use this
   * store as a dependency for a downstream module, we will merge the
   * two stores according to this policy.
   *
   * @generated from field: sf.substreams.v1.Module.KindStore.UpdatePolicy update_policy = 1;
   */
  updatePolicy = Module_KindStore_UpdatePolicy.UNSET;
  /**
   * @generated from field: string value_type = 2;
   */
  valueType = "";
  constructor(data) {
    super();
    _protobuf.proto3.util.initPartial(data, this);
  }
  static runtime = _protobuf.proto3;
  static typeName = "sf.substreams.v1.Module.KindStore";
  static fields = _protobuf.proto3.util.newFieldList(() => [{
    no: 1,
    name: "update_policy",
    kind: "enum",
    T: _protobuf.proto3.getEnumType(Module_KindStore_UpdatePolicy)
  }, {
    no: 2,
    name: "value_type",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }]);
  static fromBinary(bytes, options) {
    return new Module_KindStore().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new Module_KindStore().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Module_KindStore().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return _protobuf.proto3.util.equals(Module_KindStore, a, b);
  }
}
/**
 * @generated from enum sf.substreams.v1.Module.KindStore.UpdatePolicy
 */
exports.Module_KindStore = Module_KindStore;
var Module_KindStore_UpdatePolicy;
(function (Module_KindStore_UpdatePolicy) {
  /**
   * @generated from enum value: UPDATE_POLICY_UNSET = 0;
   */
  Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["UNSET"] = 0] = "UNSET";
  /**
   * Provides a store where you can `set()` keys, and the latest key wins
   *
   * @generated from enum value: UPDATE_POLICY_SET = 1;
   */
  Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["SET"] = 1] = "SET";
  /**
   * Provides a store where you can `set_if_not_exists()` keys, and the first key wins
   *
   * @generated from enum value: UPDATE_POLICY_SET_IF_NOT_EXISTS = 2;
   */
  Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["SET_IF_NOT_EXISTS"] = 2] = "SET_IF_NOT_EXISTS";
  /**
   * Provides a store where you can `add_*()` keys, where two stores merge by summing its values.
   *
   * @generated from enum value: UPDATE_POLICY_ADD = 3;
   */
  Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["ADD"] = 3] = "ADD";
  /**
   * Provides a store where you can `min_*()` keys, where two stores merge by leaving the minimum value.
   *
   * @generated from enum value: UPDATE_POLICY_MIN = 4;
   */
  Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["MIN"] = 4] = "MIN";
  /**
   * Provides a store where you can `max_*()` keys, where two stores merge by leaving the maximum value.
   *
   * @generated from enum value: UPDATE_POLICY_MAX = 5;
   */
  Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["MAX"] = 5] = "MAX";
  /**
   * Provides a store where you can `append()` keys, where two stores merge by concatenating the bytes in order.
   *
   * @generated from enum value: UPDATE_POLICY_APPEND = 6;
   */
  Module_KindStore_UpdatePolicy[Module_KindStore_UpdatePolicy["APPEND"] = 6] = "APPEND";
})(Module_KindStore_UpdatePolicy || (exports.Module_KindStore_UpdatePolicy = Module_KindStore_UpdatePolicy = {}));
// Retrieve enum metadata with: proto3.getEnumType(Module_KindStore_UpdatePolicy)
_protobuf.proto3.util.setEnumType(Module_KindStore_UpdatePolicy, "sf.substreams.v1.Module.KindStore.UpdatePolicy", [{
  no: 0,
  name: "UPDATE_POLICY_UNSET"
}, {
  no: 1,
  name: "UPDATE_POLICY_SET"
}, {
  no: 2,
  name: "UPDATE_POLICY_SET_IF_NOT_EXISTS"
}, {
  no: 3,
  name: "UPDATE_POLICY_ADD"
}, {
  no: 4,
  name: "UPDATE_POLICY_MIN"
}, {
  no: 5,
  name: "UPDATE_POLICY_MAX"
}, {
  no: 6,
  name: "UPDATE_POLICY_APPEND"
}]);
/**
 * @generated from message sf.substreams.v1.Module.Input
 */
class Module_Input extends _protobuf.Message {
  /**
   * @generated from oneof sf.substreams.v1.Module.Input.input
   */
  input = {
    case: undefined
  };
  constructor(data) {
    super();
    _protobuf.proto3.util.initPartial(data, this);
  }
  static runtime = _protobuf.proto3;
  static typeName = "sf.substreams.v1.Module.Input";
  static fields = _protobuf.proto3.util.newFieldList(() => [{
    no: 1,
    name: "source",
    kind: "message",
    T: Module_Input_Source,
    oneof: "input"
  }, {
    no: 2,
    name: "map",
    kind: "message",
    T: Module_Input_Map,
    oneof: "input"
  }, {
    no: 3,
    name: "store",
    kind: "message",
    T: Module_Input_Store,
    oneof: "input"
  }, {
    no: 4,
    name: "params",
    kind: "message",
    T: Module_Input_Params,
    oneof: "input"
  }]);
  static fromBinary(bytes, options) {
    return new Module_Input().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new Module_Input().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Module_Input().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return _protobuf.proto3.util.equals(Module_Input, a, b);
  }
}
/**
 * @generated from message sf.substreams.v1.Module.Input.Source
 */
exports.Module_Input = Module_Input;
class Module_Input_Source extends _protobuf.Message {
  /**
   * ex: "sf.ethereum.type.v1.Block"
   *
   * @generated from field: string type = 1;
   */
  type = "";
  constructor(data) {
    super();
    _protobuf.proto3.util.initPartial(data, this);
  }
  static runtime = _protobuf.proto3;
  static typeName = "sf.substreams.v1.Module.Input.Source";
  static fields = _protobuf.proto3.util.newFieldList(() => [{
    no: 1,
    name: "type",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }]);
  static fromBinary(bytes, options) {
    return new Module_Input_Source().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new Module_Input_Source().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Module_Input_Source().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return _protobuf.proto3.util.equals(Module_Input_Source, a, b);
  }
}
/**
 * @generated from message sf.substreams.v1.Module.Input.Map
 */
exports.Module_Input_Source = Module_Input_Source;
class Module_Input_Map extends _protobuf.Message {
  /**
   * ex: "block_to_pairs"
   *
   * @generated from field: string module_name = 1;
   */
  moduleName = "";
  constructor(data) {
    super();
    _protobuf.proto3.util.initPartial(data, this);
  }
  static runtime = _protobuf.proto3;
  static typeName = "sf.substreams.v1.Module.Input.Map";
  static fields = _protobuf.proto3.util.newFieldList(() => [{
    no: 1,
    name: "module_name",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }]);
  static fromBinary(bytes, options) {
    return new Module_Input_Map().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new Module_Input_Map().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Module_Input_Map().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return _protobuf.proto3.util.equals(Module_Input_Map, a, b);
  }
}
/**
 * @generated from message sf.substreams.v1.Module.Input.Store
 */
exports.Module_Input_Map = Module_Input_Map;
class Module_Input_Store extends _protobuf.Message {
  /**
   * @generated from field: string module_name = 1;
   */
  moduleName = "";
  /**
   * @generated from field: sf.substreams.v1.Module.Input.Store.Mode mode = 2;
   */
  mode = Module_Input_Store_Mode.UNSET;
  constructor(data) {
    super();
    _protobuf.proto3.util.initPartial(data, this);
  }
  static runtime = _protobuf.proto3;
  static typeName = "sf.substreams.v1.Module.Input.Store";
  static fields = _protobuf.proto3.util.newFieldList(() => [{
    no: 1,
    name: "module_name",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }, {
    no: 2,
    name: "mode",
    kind: "enum",
    T: _protobuf.proto3.getEnumType(Module_Input_Store_Mode)
  }]);
  static fromBinary(bytes, options) {
    return new Module_Input_Store().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new Module_Input_Store().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Module_Input_Store().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return _protobuf.proto3.util.equals(Module_Input_Store, a, b);
  }
}
/**
 * @generated from enum sf.substreams.v1.Module.Input.Store.Mode
 */
exports.Module_Input_Store = Module_Input_Store;
var Module_Input_Store_Mode;
(function (Module_Input_Store_Mode) {
  /**
   * @generated from enum value: UNSET = 0;
   */
  Module_Input_Store_Mode[Module_Input_Store_Mode["UNSET"] = 0] = "UNSET";
  /**
   * @generated from enum value: GET = 1;
   */
  Module_Input_Store_Mode[Module_Input_Store_Mode["GET"] = 1] = "GET";
  /**
   * @generated from enum value: DELTAS = 2;
   */
  Module_Input_Store_Mode[Module_Input_Store_Mode["DELTAS"] = 2] = "DELTAS";
})(Module_Input_Store_Mode || (exports.Module_Input_Store_Mode = Module_Input_Store_Mode = {}));
// Retrieve enum metadata with: proto3.getEnumType(Module_Input_Store_Mode)
_protobuf.proto3.util.setEnumType(Module_Input_Store_Mode, "sf.substreams.v1.Module.Input.Store.Mode", [{
  no: 0,
  name: "UNSET"
}, {
  no: 1,
  name: "GET"
}, {
  no: 2,
  name: "DELTAS"
}]);
/**
 * @generated from message sf.substreams.v1.Module.Input.Params
 */
class Module_Input_Params extends _protobuf.Message {
  /**
   * @generated from field: string value = 1;
   */
  value = "";
  constructor(data) {
    super();
    _protobuf.proto3.util.initPartial(data, this);
  }
  static runtime = _protobuf.proto3;
  static typeName = "sf.substreams.v1.Module.Input.Params";
  static fields = _protobuf.proto3.util.newFieldList(() => [{
    no: 1,
    name: "value",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }]);
  static fromBinary(bytes, options) {
    return new Module_Input_Params().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new Module_Input_Params().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Module_Input_Params().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return _protobuf.proto3.util.equals(Module_Input_Params, a, b);
  }
}
/**
 * @generated from message sf.substreams.v1.Module.Output
 */
exports.Module_Input_Params = Module_Input_Params;
class Module_Output extends _protobuf.Message {
  /**
   * @generated from field: string type = 1;
   */
  type = "";
  constructor(data) {
    super();
    _protobuf.proto3.util.initPartial(data, this);
  }
  static runtime = _protobuf.proto3;
  static typeName = "sf.substreams.v1.Module.Output";
  static fields = _protobuf.proto3.util.newFieldList(() => [{
    no: 1,
    name: "type",
    kind: "scalar",
    T: 9 /* ScalarType.STRING */
  }]);
  static fromBinary(bytes, options) {
    return new Module_Output().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new Module_Output().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Module_Output().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return _protobuf.proto3.util.equals(Module_Output, a, b);
  }
}
exports.Module_Output = Module_Output;
//# sourceMappingURL=modules_pb.js.map