/**
 * @since 1.0.0
 */
import type { Brand } from "@effect/data/Brand";
import type { Chunk } from "@effect/data/Chunk";
import * as D from "@effect/data/Data";
import type { Either } from "@effect/data/Either";
import type { Option } from "@effect/data/Option";
import type { Pipeable } from "@effect/data/Pipeable";
import type { Predicate, Refinement } from "@effect/data/Predicate";
import type { Arbitrary } from "@effect/schema/Arbitrary";
import type { ParseOptions } from "@effect/schema/AST";
import * as AST from "@effect/schema/AST";
import type { ParseResult } from "@effect/schema/ParseResult";
declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category symbol
 */
export type TypeId = typeof TypeId;
/**
 * @category model
 * @since 1.0.0
 */
export interface Schema<From, To = From> extends Pipeable {
    readonly _id: TypeId;
    readonly From: (_: From) => From;
    readonly To: (_: To) => To;
    readonly ast: AST.AST;
}
/**
 * @category model
 * @since 1.0.0
 */
export type From<S extends {
    readonly From: (..._: any) => any;
}> = Parameters<S["From"]>[0];
/**
 * @category model
 * @since 1.0.0
 */
export type To<S extends {
    readonly To: (..._: any) => any;
}> = Parameters<S["To"]>[0];
/**
 * @since 1.0.0
 */
export declare const from: <I, A>(schema: Schema<I, A>) => Schema<I, I>;
/**
 * @since 1.0.0
 */
export declare const to: <I, A>(schema: Schema<I, A>) => Schema<A, A>;
export { 
/**
 * @category validation
 * @since 1.0.0
 */
asserts, 
/**
 * @category decoding
 * @since 1.0.0
 */
decode, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeEither, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeOption, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodePromise, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeResult, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeSync, 
/**
 * @category encoding
 * @since 1.0.0
 */
encode, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeEither, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeOption, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodePromise, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeResult, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeSync, 
/**
 * @category validation
 * @since 1.0.0
 */
is, 
/**
 * @category parsing
 * @since 1.0.0
 */
parse, 
/**
 * @category parsing
 * @since 1.0.0
 */
parseEither, 
/**
 * @category parsing
 * @since 1.0.0
 */
parseOption, 
/**
 * @category parsing
 * @since 1.0.0
 */
parsePromise, 
/**
 * @category parsing
 * @since 1.0.0
 */
parseResult, 
/**
 * @category parsing
 * @since 1.0.0
 */
parseSync, 
/**
 * @category validation
 * @since 1.0.0
 */
validate, 
/**
 * @category validation
 * @since 1.0.0
 */
validateEither, 
/**
 * @category validation
 * @since 1.0.0
 */
validateOption, 
/**
 * @category validation
 * @since 1.0.0
 */
validatePromise, 
/**
 * @category validation
 * @since 1.0.0
 */
validateResult, 
/**
 * @category validation
 * @since 1.0.0
 */
validateSync } from "@effect/schema/Parser";
export type { 
/**
 * @since 1.0.0
 */
ToAsserts } from "@effect/schema/Parser";
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const make: <I, A>(ast: AST.AST) => Schema<I, A>;
/**
 * Tests if a value is a `Schema`.
 *
 * @category guards
 * @since 1.0.0
 */
export declare const isSchema: (input: unknown) => input is Schema<unknown, unknown>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const literal: <Literals extends readonly AST.LiteralValue[]>(...literals: Literals) => Schema<Literals[number], Literals[number]>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const uniqueSymbol: <S extends symbol>(symbol: S, annotations?: AST.Annotated["annotations"]) => Schema<S, S>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const enums: <A extends {
    [x: string]: string | number;
}>(enums: A) => Schema<A[keyof A], A[keyof A]>;
/**
 * @since 1.0.0
 */
export type Join<T> = T extends [infer Head, ...infer Tail] ? `${Head & (string | number | bigint | boolean | null | undefined)}${Tail extends [] ? "" : Join<Tail>}` : never;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const templateLiteral: <T extends [Schema<any, any>, ...Schema<any, any>[]]>(...[head, ...tail]: T) => Schema<Join<{ [K in keyof T]: To<T[K]>; }>, Join<{ [K in keyof T]: To<T[K]>; }>>;
/**
  @category combinators
  @since 1.0.0
*/
export declare const declare: (typeParameters: ReadonlyArray<Schema<any>>, type: Schema<any>, decode: (...typeParameters: ReadonlyArray<Schema<any>>) => (input: unknown, options?: ParseOptions) => ParseResult<any>, annotations?: AST.Annotated["annotations"]) => Schema<any>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const union: <Members extends readonly Schema<any, any>[]>(...members: Members) => Schema<From<Members[number]>, To<Members[number]>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const nullable: <From_1, To_1>(self: Schema<From_1, To_1>) => Schema<From_1 | null, To_1 | null>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const keyof: <I, A>(schema: Schema<I, A>) => Schema<keyof A, keyof A>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const tuple: <Elements extends readonly Schema<any, any>[]>(...elements: Elements) => Schema<{ readonly [K in keyof Elements]: From<Elements[K]>; }, { readonly [K_1 in keyof Elements]: To<Elements[K_1]>; }>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const rest: <IR, R>(rest: Schema<IR, R>) => <I extends readonly any[], A extends readonly any[]>(self: Schema<I, A>) => Schema<readonly [...I, ...IR[]], readonly [...A, ...R[]]>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const element: <IE, E>(element: Schema<IE, E>) => <I extends readonly any[], A extends readonly any[]>(self: Schema<I, A>) => Schema<readonly [...I, IE], readonly [...A, E]>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const optionalElement: <IE, E>(element: Schema<IE, E>) => <I extends readonly any[], A extends readonly any[]>(self: Schema<I, A>) => Schema<readonly [...I, IE?], readonly [...A, E?]>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const array: <I, A>(item: Schema<I, A>) => Schema<readonly I[], readonly A[]>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const nonEmptyArray: <I, A>(item: Schema<I, A>) => Schema<readonly [I, ...I[]], readonly [A, ...A[]]>;
/**
 * @since 1.0.0
 */
export type Spread<A> = {
    [K in keyof A]: A[K];
} extends infer B ? B : never;
/**
 * @since 1.0.0
 */
export interface PropertySignature<From, FromIsOptional, To, ToIsOptional> {
    readonly From: (_: From) => From;
    readonly FromIsOptional: FromIsOptional;
    readonly To: (_: To) => To;
    readonly ToIsOptional: ToIsOptional;
    readonly optional: () => PropertySignature<From, true, To, true>;
    readonly withDefault: (value: () => To) => PropertySignature<From, true, To, false>;
    readonly toOption: () => PropertySignature<From, true, Option<To>, false>;
}
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const propertySignature: <I, A>(schema: Schema<I, A>, annotations?: AST.Annotated["annotations"]) => PropertySignature<I, false, A, false>;
/**
 * @since 1.0.0
 */
export declare const optional: <I, A>(schema: Schema<I, A>, annotations?: AST.Annotated["annotations"]) => PropertySignature<I, true, A, true>;
/**
 * @since 1.0.0
 */
export type ToOptionalKeys<Fields> = {
    [K in keyof Fields]: Fields[K] extends PropertySignature<any, boolean, any, true> | PropertySignature<never, boolean, never, true> ? K : never;
}[keyof Fields];
/**
 * @since 1.0.0
 */
export type FromOptionalKeys<Fields> = {
    [K in keyof Fields]: Fields[K] extends PropertySignature<any, true, any, boolean> | PropertySignature<never, true, never, boolean> ? K : never;
}[keyof Fields];
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const struct: <Fields extends Record<PropertyKey, Schema<any, any> | Schema<never, never> | PropertySignature<any, boolean, any, boolean> | PropertySignature<never, boolean, never, boolean>>>(fields: Fields) => Schema<Spread<{ readonly [K in Exclude<keyof Fields, FromOptionalKeys<Fields>>]: From<Fields[K]>; } & { readonly [K_1 in FromOptionalKeys<Fields>]?: From<Fields[K_1]>; }>, Spread<{ readonly [K_2 in Exclude<keyof Fields, ToOptionalKeys<Fields>>]: To<Fields[K_2]>; } & { readonly [K_3 in ToOptionalKeys<Fields>]?: To<Fields[K_3]>; }>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const pick: <A, Keys extends readonly (keyof A)[]>(...keys: Keys) => <I extends { [K in keyof A]?: any; }>(self: Schema<I, A>) => Schema<Spread<Pick<I, Keys[number]>>, Spread<Pick<A, Keys[number]>>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const omit: <A, Keys extends readonly (keyof A)[]>(...keys: Keys) => <I extends { [K in keyof A]?: any; }>(self: Schema<I, A>) => Schema<Spread<Omit<I, Keys[number]>>, Spread<Omit<A, Keys[number]>>>;
/**
 * @category model
 * @since 1.0.0
 */
export interface BrandSchema<From, To extends Brand<any>> extends Schema<From, To>, Brand.Constructor<To> {
}
/**
 * Returns a nominal branded schema by applying a brand to a given schema.
 *
 * ```
 * Schema<A> + B -> Schema<A & Brand<B>>
 * ```
 *
 * @param self - The input schema to be combined with the brand.
 * @param brand - The brand to apply.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const Int = S.number.pipe(S.int(), S.brand("Int"))
 * type Int = S.To<typeof Int> // number & Brand<"Int">
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const brand: <B extends string | symbol, A>(brand: B, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => BrandSchema<I, A & Brand<B>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const partial: <I, A>(self: Schema<I, A>) => Schema<Spread<Partial<I>>, Spread<Partial<A>>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const required: <I, A>(self: Schema<I, A>) => Schema<Spread<Required<I>>, Spread<Required<A>>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const record: <K extends string | symbol, I, A>(key: Schema<K, K>, value: Schema<I, A>) => Schema<{ readonly [k in K]: I; }, { readonly [k_1 in K]: A; }>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const extend: {
    <IB, B>(that: Schema<IB, B>): <I, A>(self: Schema<I, A>) => Schema<Spread<I & IB>, Spread<A & B>>;
    <I, A, IB, B>(self: Schema<I, A>, that: Schema<IB, B>): Schema<Spread<I & IB>, Spread<A & B>>;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const compose: {
    <B, C>(bc: Schema<B, C>): <A>(ab: Schema<A, B>) => Schema<A, C>;
    <A, B, C>(ab: Schema<A, B>, bc: Schema<B, C>): Schema<A, C>;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const lazy: <I, A = I>(f: () => Schema<I, A>, annotations?: AST.Annotated["annotations"]) => Schema<I, A>;
/**
 * @category model
 * @since 1.0.0
 */
export type AnnotationOptions<A> = {
    typeId?: AST.TypeAnnotation | {
        id: AST.TypeAnnotation;
        params: unknown;
    };
    message?: AST.MessageAnnotation<A>;
    identifier?: AST.IdentifierAnnotation;
    title?: AST.TitleAnnotation;
    description?: AST.DescriptionAnnotation;
    examples?: AST.ExamplesAnnotation;
    documentation?: AST.DocumentationAnnotation;
    jsonSchema?: AST.JSONSchemaAnnotation;
    arbitrary?: (...args: ReadonlyArray<Arbitrary<any>>) => Arbitrary<any>;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export declare function filter<C extends A, B extends A, A = C>(refinement: Refinement<A, B>, options?: AnnotationOptions<A>): <I>(self: Schema<I, C>) => Schema<I, C & B>;
export declare function filter<B extends A, A = B>(predicate: Predicate<A>, options?: AnnotationOptions<A>): <I>(self: Schema<I, B>) => Schema<I, B>;
/**
  Create a new `Schema` by transforming the input and output of an existing `Schema`
  using the provided decoding functions.

  @category combinators
  @since 1.0.0
 */
export declare const transformResult: {
    <I2, A2, A1>(to: Schema<I2, A2>, decode: (a1: A1, options?: ParseOptions) => ParseResult<I2>, encode: (i2: I2, options?: ParseOptions) => ParseResult<A1>): <I1>(self: Schema<I1, A1>) => Schema<I1, A2>;
    <I1, A1, I2, A2>(from: Schema<I1, A1>, to: Schema<I2, A2>, decode: (a1: A1, options?: ParseOptions) => ParseResult<I2>, encode: (i2: I2, options?: ParseOptions) => ParseResult<A1>): Schema<I1, A2>;
};
/**
  Create a new `Schema` by transforming the input and output of an existing `Schema`
  using the provided mapping functions.

  @category combinators
  @since 1.0.0
*/
export declare const transform: {
    <I2, A2, A1>(to: Schema<I2, A2>, decode: (a1: A1) => I2, encode: (i2: I2) => A1): <I1>(self: Schema<I1, A1>) => Schema<I1, A2>;
    <I1, A1, I2, A2>(from: Schema<I1, A1>, to: Schema<I2, A2>, decode: (a1: A1) => I2, encode: (i2: I2) => A1): Schema<I1, A2>;
};
/**
 * Attaches a property signature with the specified key and value to the schema.
 * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
 * but rather maps to another schema, for example when you want to add a discriminant to a simple union.
 *
 * @param self - The input schema.
 * @param key - The name of the property to add to the schema.
 * @param value - The value of the property to add to the schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { pipe } from "@effect/data/Function"
 *
 * const Circle = S.struct({ radius: S.number })
 * const Square = S.struct({ sideLength: S.number })
 * const Shape = S.union(
 *   Circle.pipe(S.attachPropertySignature("kind", "circle")),
 *   Square.pipe(S.attachPropertySignature("kind", "square"))
 * )
 *
 * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
 *   kind: "circle",
 *   radius: 10
 * })
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const attachPropertySignature: <K extends PropertyKey, V extends AST.LiteralValue>(key: K, value: V) => <I, A extends object>(schema: Schema<I, A>) => Schema<I, Spread<A & { readonly [k in K]: V; }>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const annotations: (annotations: AST.Annotated["annotations"]) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const message: (message: AST.MessageAnnotation<unknown>) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const identifier: (identifier: AST.IdentifierAnnotation) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const title: (title: AST.TitleAnnotation) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const description: (description: AST.DescriptionAnnotation) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const examples: (examples: AST.ExamplesAnnotation) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const documentation: (documentation: AST.DocumentationAnnotation) => <I, A>(self: Schema<I, A>) => Schema<I, A>;
declare const _undefined: Schema<undefined>;
declare const _void: Schema<void>;
declare const _null: Schema<null>;
export { 
/**
 * @category primitives
 * @since 1.0.0
 */
_null as null, 
/**
 * @category primitives
 * @since 1.0.0
 */
_undefined as undefined, 
/**
 * @category primitives
 * @since 1.0.0
 */
_void as void };
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const never: Schema<never>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const unknown: Schema<unknown>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const any: Schema<any>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const string: Schema<string>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const number: Schema<number>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const boolean: Schema<boolean>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const bigint: Schema<bigint>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const symbol: Schema<symbol>;
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const object: Schema<object>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanBigintTypeId = "@effect/schema/GreaterThanBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const greaterThanBigint: <A extends bigint>(min: bigint, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanOrEqualToBigintTypeId = "@effect/schema/GreaterThanOrEqualToBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const greaterThanOrEqualToBigint: <A extends bigint>(min: bigint, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanBigintTypeId = "@effect/schema/LessThanBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const lessThanBigint: <A extends bigint>(max: bigint, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanOrEqualToBigintTypeId = "@effect/schema/LessThanOrEqualToBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const lessThanOrEqualToBigint: <A extends bigint>(max: bigint, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BetweenBigintTypeId = "@effect/schema/BetweenBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const betweenBigint: <A extends bigint>(min: bigint, max: bigint, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const PositiveBigintTypeId = "@effect/schema/PositiveBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const positiveBigint: <A extends bigint>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NegativeBigintTypeId = "@effect/schema/NegativeBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const negativeBigint: <A extends bigint>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonNegativeBigintTypeId = "@effect/schema/NonNegativeBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const nonNegativeBigint: <A extends bigint>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonPositiveBigintTypeId = "@effect/schema/NonPositiveBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
export declare const nonPositiveBigint: <A extends bigint>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * Clamps a bigint between a minimum and a maximum value.
 *
 * @category bigint
 * @since 1.0.0
 */
export declare const clampBigint: (min: bigint, max: bigint) => <I, A extends bigint>(self: Schema<I, A>) => Schema<I, A>;
/**
 * This combinator transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * @param self - The schema representing the input string
 *
 * @category bigint
 * @since 1.0.0
 */
export declare const bigintFromString: <I, A extends string>(self: Schema<I, A>) => Schema<I, bigint>;
/**
 * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * @category bigint
 * @since 1.0.0
 */
export declare const BigintFromString: Schema<string, bigint>;
/**
 * Negates a boolean value
 *
 * @category boolean
 * @since 1.0.0
 */
export declare const not: <I>(self: Schema<I, boolean>) => Schema<I, boolean>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BrandTypeId = "@effect/schema/BrandTypeId";
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const fromBrand: <C extends Brand<string | symbol>>(constructor: Brand.Constructor<C>, options?: AnnotationOptions<Brand.Unbranded<C>> | undefined) => <I, A extends Brand.Unbranded<C>>(self: Schema<I, A>) => Schema<I, A & C>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const chunkFromSelf: <I, A>(item: Schema<I, A>) => Schema<Chunk<I>, Chunk<A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const chunk: <I, A>(item: Schema<I, A>) => Schema<readonly I[], Chunk<A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const dataFromSelf: <I extends readonly any[] | Readonly<Record<string, any>>, A extends readonly any[] | Readonly<Record<string, any>>>(item: Schema<I, A>) => Schema<D.Data<I>, D.Data<A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const data: <I extends readonly any[] | Readonly<Record<string, any>>, A extends readonly any[] | Readonly<Record<string, any>>>(item: Schema<I, A>) => Schema<I, D.Data<A>>;
/**
 * @category Date
 * @since 1.0.0
 */
export declare const DateFromSelf: Schema<Date>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const ValidDateTypeId = "@effect/schema/ValidDateTypeId";
/**
 * A filter excluding invalid dates (e.g. `new Date("fail")`).
 *
 * @category Date
 * @since 1.0.0
 */
export declare const validDate: (options?: AnnotationOptions<Date>) => <I>(self: Schema<I, Date>) => Schema<I, Date>;
/**
 * A schema representing valid dates, e.g. `new Date("fail")` is excluded, even though it is an instance of `Date`.
 *
 * @category Date
 * @since 1.0.0
 */
export declare const ValidDateFromSelf: Schema<Date, Date>;
/**
  A combinator that transforms a `string` into a valid `Date`.

  @category Date
  @since 1.0.0
*/
export declare const dateFromString: <I, A extends string>(self: Schema<I, A>) => Schema<I, Date>;
declare const _Date: Schema<string, Date>;
export { 
/**
 * A schema that transforms a `string` into a valid `Date`.
 *
 * @category Date
 * @since 1.0.0
 */
_Date as Date };
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const eitherFromSelf: <IE, E, IA, A>(left: Schema<IE, E>, right: Schema<IA, A>) => Schema<Either<IE, IA>, Either<E, A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const either: <IE, E, IA, A>(left: Schema<IE, E>, right: Schema<IA, A>) => Schema<{
    readonly _tag: "Left";
    readonly left: IE;
} | {
    readonly _tag: "Right";
    readonly right: IA;
}, Either<E, A>>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const JsonNumberTypeId = "@effect/schema/JsonNumberTypeId";
/**
 * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
 * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
 * format.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const is = S.is(S.JsonNumber)
 *
 * assert.deepStrictEqual(is(42), true)
 * assert.deepStrictEqual(is(Number.NaN), false)
 * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
 * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
 *
 * @category constructors
 * @since 1.0.0
 */
export declare const JsonNumber: Schema<number, number>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const FiniteTypeId = "@effect/schema/FiniteTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const finite: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanTypeId = "@effect/schema/GreaterThanTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const greaterThan: <A extends number>(min: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanOrEqualToTypeId = "@effect/schema/GreaterThanOrEqualToTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const greaterThanOrEqualTo: <A extends number>(min: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MultipleOfTypeId = "@effect/schema/MultipleOfTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const multipleOf: <A extends number>(divisor: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const IntTypeId = "@effect/schema/IntTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const int: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanTypeId = "@effect/schema/LessThanTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const lessThan: <A extends number>(max: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanOrEqualToTypeId = "@effect/schema/LessThanOrEqualToTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const lessThanOrEqualTo: <A extends number>(max: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BetweenTypeId = "@effect/schema/BetweenTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const between: <A extends number>(min: number, max: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonNaNTypeId = "@effect/schema/NonNaNTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const nonNaN: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const PositiveTypeId = "@effect/schema/PositiveTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const positive: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NegativeTypeId = "@effect/schema/NegativeTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const negative: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonNegativeTypeId = "@effect/schema/NonNegativeTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const nonNegative: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonPositiveTypeId = "@effect/schema/NonPositiveTypeId";
/**
 * @category number
 * @since 1.0.0
 */
export declare const nonPositive: <A extends number>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * Clamps a number between a minimum and a maximum value.
 *
 * @category number
 * @since 1.0.0
 */
export declare const clamp: (min: number, max: number) => <I, A extends number>(self: Schema<I, A>) => Schema<I, A>;
/**
 * This combinator transforms a `string` into a `number` by parsing the string using the `Number` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @param self - The schema representing the input string
 *
 * @category number
 * @since 1.0.0
 */
export declare const numberFromString: <I, A extends string>(self: Schema<I, A>) => Schema<I, number>;
/**
 * This schema transforms a `string` into a `number` by parsing the string using the `Number` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category number
 * @since 1.0.0
 */
export declare const NumberFromString: Schema<string, number>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const InstanceOfTypeId = "@effect/schema/InstanceOfTypeId";
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const instanceOf: <A extends abstract new (...args: any) => any>(constructor: A, options?: AnnotationOptions<object>) => Schema<InstanceType<A>, InstanceType<A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const optionFromSelf: <I, A>(value: Schema<I, A>) => Schema<Option<I>, Option<A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const option: <I, A>(value: Schema<I, A>) => Schema<{
    readonly _tag: "None";
} | {
    readonly _tag: "Some";
    readonly value: I;
}, Option<A>>;
/**
 * @category option
 * @since 1.0.0
 */
export declare const optionFromNullable: <I, A>(value: Schema<I, A>) => Schema<I | null, Option<A>>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MinItemsTypeId = "@effect/schema/MinItemsTypeId";
/**
 * @category array
 * @since 1.0.0
 */
export declare const minItems: <A>(n: number, options?: AnnotationOptions<readonly A[]> | undefined) => <I>(self: Schema<I, readonly A[]>) => Schema<I, readonly A[]>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MaxItemsTypeId = "@effect/schema/MaxItemsTypeId";
/**
 * @category array
 * @since 1.0.0
 */
export declare const maxItems: <A>(n: number, options?: AnnotationOptions<readonly A[]> | undefined) => <I>(self: Schema<I, readonly A[]>) => Schema<I, readonly A[]>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const ItemsCountTypeId = "@effect/schema/ItemsCountTypeId";
/**
 * @category array
 * @since 1.0.0
 */
export declare const itemsCount: <A>(n: number, options?: AnnotationOptions<readonly A[]> | undefined) => <I>(self: Schema<I, readonly A[]>) => Schema<I, readonly A[]>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const readonlyMapFromSelf: <IK, K, IV, V>(key: Schema<IK, K>, value: Schema<IV, V>) => Schema<ReadonlyMap<IK, IV>, ReadonlyMap<K, V>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const readonlyMap: <IK, K, IV, V>(key: Schema<IK, K>, value: Schema<IV, V>) => Schema<readonly (readonly [IK, IV])[], ReadonlyMap<K, V>>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const readonlySetFromSelf: <I, A>(item: Schema<I, A>) => Schema<ReadonlySet<I>, ReadonlySet<A>>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const readonlySet: <I, A>(item: Schema<I, A>) => Schema<readonly I[], ReadonlySet<A>>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const TrimmedTypeId = "@effect/schema/TrimmedTypeId";
/**
 * Verifies that a string contains no leading or trailing whitespaces.
 *
 * Note. This combinator does not make any transformations, it only validates.
 * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.
 *
 * @category string
 * @since 1.0.0
 */
export declare const trimmed: <A extends string>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MaxLengthTypeId = "@effect/schema/MaxLengthTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export declare const maxLength: <A extends string>(maxLength: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MinLengthTypeId = "@effect/schema/MinLengthTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export declare const minLength: <A extends string>(minLength: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const PatternTypeId = "@effect/schema/PatternTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export declare const pattern: <A extends string>(regex: RegExp, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const StartsWithTypeId = "@effect/schema/StartsWithTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export declare const startsWith: <A extends string>(startsWith: string, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const EndsWithTypeId = "@effect/schema/EndsWithTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export declare const endsWith: <A extends string>(endsWith: string, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const IncludesTypeId = "@effect/schema/IncludesTypeId";
/**
 * @category string
 * @since 1.0.0
 */
export declare const includes: <A extends string>(searchString: string, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * This combinator allows removing whitespaces from the beginning and end of a string.
 *
 * @category string
 * @since 1.0.0
 */
export declare const trim: <I, A extends string>(self: Schema<I, A>) => Schema<I, A>;
/**
 * This schema allows removing whitespaces from the beginning and end of a string.
 *
 * @category string
 * @since 1.0.0
 */
export declare const Trim: Schema<string, string>;
/**
 * This combinator allows splitting a string into an array of strings.
 *
 * @category string
 * @since 1.0.0
 */
export declare const split: {
    (separator: string): <I>(self: Schema<I, string>) => Schema<I, ReadonlyArray<string>>;
    <I>(self: Schema<I, string>, separator: string): Schema<I, ReadonlyArray<string>>;
};
/**
 * @category type id
 * @since 1.0.0
 */
export declare const UUIDTypeId = "@effect/schema/UUIDTypeId";
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const UUID: Schema<string>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const ULIDTypeId = "@effect/schema/ULIDTypeId";
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const ULID: Schema<string>;
/**
 * @category string
 * @since 1.0.0
 */
export declare const length: <A extends string>(length: number, options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
/**
 * @category string
 * @since 1.0.0
 */
export declare const nonEmpty: <A extends string>(options?: AnnotationOptions<A> | undefined) => <I>(self: Schema<I, A>) => Schema<I, A>;
//# sourceMappingURL=Schema.d.ts.map