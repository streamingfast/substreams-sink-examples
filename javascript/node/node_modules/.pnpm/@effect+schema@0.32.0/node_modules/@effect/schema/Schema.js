"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.array = exports.any = exports.annotations = exports.ValidDateTypeId = exports.ValidDateFromSelf = exports.UUIDTypeId = exports.UUID = exports.ULIDTypeId = exports.ULID = exports.TrimmedTypeId = exports.Trim = exports.StartsWithTypeId = exports.PositiveTypeId = exports.PositiveBigintTypeId = exports.PatternTypeId = exports.NumberFromString = exports.NonPositiveTypeId = exports.NonPositiveBigintTypeId = exports.NonNegativeTypeId = exports.NonNegativeBigintTypeId = exports.NonNaNTypeId = exports.NegativeTypeId = exports.NegativeBigintTypeId = exports.MultipleOfTypeId = exports.MinLengthTypeId = exports.MinItemsTypeId = exports.MaxLengthTypeId = exports.MaxItemsTypeId = exports.LessThanTypeId = exports.LessThanOrEqualToTypeId = exports.LessThanOrEqualToBigintTypeId = exports.LessThanBigintTypeId = exports.JsonNumberTypeId = exports.JsonNumber = exports.ItemsCountTypeId = exports.IntTypeId = exports.InstanceOfTypeId = exports.IncludesTypeId = exports.GreaterThanTypeId = exports.GreaterThanOrEqualToTypeId = exports.GreaterThanOrEqualToBigintTypeId = exports.GreaterThanBigintTypeId = exports.FiniteTypeId = exports.EndsWithTypeId = exports.DateFromSelf = exports.Date = exports.BrandTypeId = exports.BigintFromString = exports.BetweenTypeId = exports.BetweenBigintTypeId = void 0;
Object.defineProperty(exports, "asserts", {
  enumerable: true,
  get: function () {
    return P.asserts;
  }
});
exports.declare = exports.dateFromString = exports.dataFromSelf = exports.data = exports.compose = exports.clampBigint = exports.clamp = exports.chunkFromSelf = exports.chunk = exports.brand = exports.boolean = exports.bigintFromString = exports.bigint = exports.betweenBigint = exports.between = exports.attachPropertySignature = void 0;
Object.defineProperty(exports, "decode", {
  enumerable: true,
  get: function () {
    return P.decode;
  }
});
Object.defineProperty(exports, "decodeEither", {
  enumerable: true,
  get: function () {
    return P.decodeEither;
  }
});
Object.defineProperty(exports, "decodeOption", {
  enumerable: true,
  get: function () {
    return P.decodeOption;
  }
});
Object.defineProperty(exports, "decodePromise", {
  enumerable: true,
  get: function () {
    return P.decodePromise;
  }
});
Object.defineProperty(exports, "decodeResult", {
  enumerable: true,
  get: function () {
    return P.decodeResult;
  }
});
Object.defineProperty(exports, "decodeSync", {
  enumerable: true,
  get: function () {
    return P.decodeSync;
  }
});
exports.element = exports.eitherFromSelf = exports.either = exports.documentation = exports.description = void 0;
Object.defineProperty(exports, "encode", {
  enumerable: true,
  get: function () {
    return P.encode;
  }
});
Object.defineProperty(exports, "encodeEither", {
  enumerable: true,
  get: function () {
    return P.encodeEither;
  }
});
Object.defineProperty(exports, "encodeOption", {
  enumerable: true,
  get: function () {
    return P.encodeOption;
  }
});
Object.defineProperty(exports, "encodePromise", {
  enumerable: true,
  get: function () {
    return P.encodePromise;
  }
});
Object.defineProperty(exports, "encodeResult", {
  enumerable: true,
  get: function () {
    return P.encodeResult;
  }
});
Object.defineProperty(exports, "encodeSync", {
  enumerable: true,
  get: function () {
    return P.encodeSync;
  }
});
exports.extend = exports.examples = exports.enums = exports.endsWith = void 0;
exports.filter = filter;
exports.int = exports.instanceOf = exports.includes = exports.identifier = exports.greaterThanOrEqualToBigint = exports.greaterThanOrEqualTo = exports.greaterThanBigint = exports.greaterThan = exports.fromBrand = exports.from = exports.finite = void 0;
Object.defineProperty(exports, "is", {
  enumerable: true,
  get: function () {
    return P.is;
  }
});
exports.optionalElement = exports.optional = exports.optionFromSelf = exports.optionFromNullable = exports.option = exports.omit = exports.object = exports.numberFromString = exports.number = exports.nullable = exports.null = exports.not = exports.nonPositiveBigint = exports.nonPositive = exports.nonNegativeBigint = exports.nonNegative = exports.nonNaN = exports.nonEmptyArray = exports.nonEmpty = exports.never = exports.negativeBigint = exports.negative = exports.multipleOf = exports.minLength = exports.minItems = exports.message = exports.maxLength = exports.maxItems = exports.make = exports.literal = exports.lessThanOrEqualToBigint = exports.lessThanOrEqualTo = exports.lessThanBigint = exports.lessThan = exports.length = exports.lazy = exports.keyof = exports.itemsCount = exports.isSchema = void 0;
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return P.parse;
  }
});
Object.defineProperty(exports, "parseEither", {
  enumerable: true,
  get: function () {
    return P.parseEither;
  }
});
Object.defineProperty(exports, "parseOption", {
  enumerable: true,
  get: function () {
    return P.parseOption;
  }
});
Object.defineProperty(exports, "parsePromise", {
  enumerable: true,
  get: function () {
    return P.parsePromise;
  }
});
Object.defineProperty(exports, "parseResult", {
  enumerable: true,
  get: function () {
    return P.parseResult;
  }
});
Object.defineProperty(exports, "parseSync", {
  enumerable: true,
  get: function () {
    return P.parseSync;
  }
});
exports.validDate = exports.unknown = exports.uniqueSymbol = exports.union = exports.undefined = exports.tuple = exports.trimmed = exports.trim = exports.transformResult = exports.transform = exports.to = exports.title = exports.templateLiteral = exports.symbol = exports.struct = exports.string = exports.startsWith = exports.split = exports.rest = exports.required = exports.record = exports.readonlySetFromSelf = exports.readonlySet = exports.readonlyMapFromSelf = exports.readonlyMap = exports.propertySignature = exports.positiveBigint = exports.positive = exports.pick = exports.pattern = exports.partial = void 0;
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return P.validate;
  }
});
Object.defineProperty(exports, "validateEither", {
  enumerable: true,
  get: function () {
    return P.validateEither;
  }
});
Object.defineProperty(exports, "validateOption", {
  enumerable: true,
  get: function () {
    return P.validateOption;
  }
});
Object.defineProperty(exports, "validatePromise", {
  enumerable: true,
  get: function () {
    return P.validatePromise;
  }
});
Object.defineProperty(exports, "validateResult", {
  enumerable: true,
  get: function () {
    return P.validateResult;
  }
});
Object.defineProperty(exports, "validateSync", {
  enumerable: true,
  get: function () {
    return P.validateSync;
  }
});
exports.void = void 0;
var B = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Bigint"));
var _Brand = /*#__PURE__*/require("@effect/data/Brand");
var C = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Chunk"));
var D = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Data"));
var E = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Either"));
var Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Equal"));
var _Function = /*#__PURE__*/require("@effect/data/Function");
var N = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Number"));
var O = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var _Pipeable = /*#__PURE__*/require("@effect/data/Pipeable");
var _Predicate = /*#__PURE__*/require("@effect/data/Predicate");
var RA = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/ReadonlyArray"));
var S = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/String"));
var AST = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/schema/AST"));
var I = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/schema/internal/common"));
var P = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/schema/Parser"));
var PR = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/schema/ParseResult"));
var _TreeFormatter = /*#__PURE__*/require("@effect/schema/TreeFormatter");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 */

const TypeId = /*#__PURE__*/Symbol.for("@effect/schema/Schema");
/**
 * @since 1.0.0
 */
const from = schema => make(AST.from(schema.ast));
/**
 * @since 1.0.0
 */
exports.from = from;
const to = schema => make(AST.to(schema.ast));
/* c8 ignore start */
exports.to = to;
/* c8 ignore end */
// ---------------------------------------------
// constructors
// ---------------------------------------------
class SchemaImpl {
  ast;
  _id = TypeId;
  From;
  To;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
const make = ast => new SchemaImpl(ast);
/**
 * Tests if a value is a `Schema`.
 *
 * @category guards
 * @since 1.0.0
 */
exports.make = make;
const isSchema = input => (0, _Predicate.isObject)(input) && "_id" in input && input["_id"] === TypeId;
exports.isSchema = isSchema;
const makeLiteral = value => make(AST.createLiteral(value));
/**
 * @category constructors
 * @since 1.0.0
 */
const literal = (...literals) => union(...literals.map(literal => makeLiteral(literal)));
/**
 * @category constructors
 * @since 1.0.0
 */
exports.literal = literal;
const uniqueSymbol = (symbol, annotations) => make(AST.createUniqueSymbol(symbol, annotations));
/**
 * @category constructors
 * @since 1.0.0
 */
exports.uniqueSymbol = uniqueSymbol;
const enums = enums => make(AST.createEnums(Object.keys(enums).filter(key => typeof enums[enums[key]] !== "number").map(key => [key, enums[key]])));
/**
 * @category constructors
 * @since 1.0.0
 */
exports.enums = enums;
const templateLiteral = (...[head, ...tail]) => {
  let types = getTemplateLiterals(head.ast);
  for (const span of tail) {
    types = RA.flatMap(types, a => getTemplateLiterals(span.ast).map(b => combineTemplateLiterals(a, b)));
  }
  return make(AST.createUnion(types));
};
exports.templateLiteral = templateLiteral;
const combineTemplateLiterals = (a, b) => {
  if (AST.isLiteral(a)) {
    return AST.isLiteral(b) ? AST.createLiteral(String(a.literal) + String(b.literal)) : AST.createTemplateLiteral(String(a.literal) + b.head, b.spans);
  }
  if (AST.isLiteral(b)) {
    return AST.createTemplateLiteral(a.head, RA.modifyNonEmptyLast(a.spans, span => ({
      ...span,
      literal: span.literal + String(b.literal)
    })));
  }
  return AST.createTemplateLiteral(a.head, RA.appendAll(RA.modifyNonEmptyLast(a.spans, span => ({
    ...span,
    literal: span.literal + String(b.head)
  })), b.spans));
};
const getTemplateLiterals = ast => {
  switch (ast._tag) {
    case "Literal":
      return [ast];
    case "NumberKeyword":
    case "StringKeyword":
      return [AST.createTemplateLiteral("", [{
        type: ast,
        literal: ""
      }])];
    case "Union":
      return RA.flatMap(ast.types, getTemplateLiterals);
    default:
      throw new Error(`templateLiteral: unsupported template literal span ${ast._tag}`);
  }
};
/**
  @category combinators
  @since 1.0.0
*/
const declare = (typeParameters, type, decode, annotations) => make(AST.createDeclaration(typeParameters.map(tp => tp.ast), type.ast, (...typeParameters) => decode(...typeParameters.map(make)), annotations));
// ---------------------------------------------
// combinators
// ---------------------------------------------
/**
 * @category combinators
 * @since 1.0.0
 */
exports.declare = declare;
const union = (...members) => make(AST.createUnion(members.map(m => m.ast)));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.union = union;
const nullable = self => union(_null, self);
/**
 * @category combinators
 * @since 1.0.0
 */
exports.nullable = nullable;
const keyof = schema => make(AST.keyof(schema.ast));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.keyof = keyof;
const tuple = (...elements) => make(AST.createTuple(elements.map(schema => AST.createElement(schema.ast, false)), O.none(), true));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.tuple = tuple;
const rest = rest => self => {
  if (AST.isTuple(self.ast)) {
    return make(AST.appendRestElement(self.ast, rest.ast));
  }
  throw new Error("`rest` is not supported on this schema");
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.rest = rest;
const element = element => self => {
  if (AST.isTuple(self.ast)) {
    return make(AST.appendElement(self.ast, AST.createElement(element.ast, false)));
  }
  throw new Error("`element` is not supported on this schema");
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.element = element;
const optionalElement = element => self => {
  if (AST.isTuple(self.ast)) {
    return make(AST.appendElement(self.ast, AST.createElement(element.ast, true)));
  }
  throw new Error("`optionalElement` is not supported on this schema");
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.optionalElement = optionalElement;
const array = item => make(AST.createTuple([], O.some([item.ast]), true));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.array = array;
const nonEmptyArray = item => tuple(item).pipe(rest(item));
exports.nonEmptyArray = nonEmptyArray;
class PropertySignatureImpl {
  _from;
  _annotations;
  _optional;
  From;
  FromIsOptional;
  To;
  ToIsOptional;
  constructor(_from, _annotations, _optional) {
    this._from = _from;
    this._annotations = _annotations;
    this._optional = _optional;
  }
  optional() {
    if (this._optional) {
      throw new Error(`duplicate optional configuration`);
    }
    return new PropertySignatureImpl(this._from, this._annotations, {
      to: "optional"
    });
  }
  withDefault(value) {
    if (this._optional && this._optional.to !== "optional") {
      throw new Error(`duplicate optional configuration`);
    }
    return new PropertySignatureImpl(this._from, this._annotations, {
      to: "default",
      value
    });
  }
  toOption() {
    if (this._optional && this._optional.to !== "optional") {
      throw new Error(`duplicate optional configuration`);
    }
    return new PropertySignatureImpl(this._from, this._annotations, {
      to: "Option"
    });
  }
}
/**
 * @since 1.0.0
 * @category constructors
 */
const propertySignature = (schema, annotations) => new PropertySignatureImpl(schema.ast, annotations);
/**
 * @since 1.0.0
 */
exports.propertySignature = propertySignature;
const optional = (schema, annotations) => propertySignature(schema, annotations).optional();
/**
 * @category combinators
 * @since 1.0.0
 */
exports.optional = optional;
const struct = fields => {
  const ownKeys = I.ownKeys(fields);
  const propertySignatures = [];
  const fromPropertySignatures = [];
  const toPropertySignatures = [];
  const propertySignatureTransformations = [];
  for (let i = 0; i < ownKeys.length; i++) {
    const key = ownKeys[i];
    const field = fields[key];
    if (field instanceof PropertySignatureImpl) {
      const optional = field._optional;
      if (optional) {
        switch (optional.to) {
          case "optional":
            {
              propertySignatures.push(AST.createPropertySignature(key, field._from, true, true, field._annotations));
              fromPropertySignatures.push(AST.createPropertySignature(key, field._from, true, true));
              toPropertySignatures.push(AST.createPropertySignature(key, AST.to(field._from), true, true, field._annotations));
              break;
            }
          case "default":
            {
              fromPropertySignatures.push(AST.createPropertySignature(key, field._from, true, true));
              toPropertySignatures.push(AST.createPropertySignature(key, AST.to(field._from), false, true, field._annotations));
              propertySignatureTransformations.push(AST.createPropertySignatureTransformation(key, key, O.orElse(() => O.some(optional.value())), _Function.identity));
              break;
            }
          case "Option":
            {
              fromPropertySignatures.push(AST.createPropertySignature(key, field._from, true, true));
              toPropertySignatures.push(AST.createPropertySignature(key, optionFromSelf(make(AST.to(field._from))).ast, false, true, field._annotations));
              propertySignatureTransformations.push(AST.createPropertySignatureTransformation(key, key, O.some, O.flatten));
              break;
            }
        }
      } else {
        propertySignatures.push(AST.createPropertySignature(key, field._from, false, true, field._annotations));
        fromPropertySignatures.push(AST.createPropertySignature(key, field._from, false, true));
        toPropertySignatures.push(AST.createPropertySignature(key, AST.to(field._from), false, true, field._annotations));
      }
    } else {
      propertySignatures.push(AST.createPropertySignature(key, field.ast, false, true));
      fromPropertySignatures.push(AST.createPropertySignature(key, field.ast, false, true));
      toPropertySignatures.push(AST.createPropertySignature(key, AST.to(field.ast), false, true));
    }
  }
  if (propertySignatureTransformations.length > 0) {
    return make(AST.createTransformByPropertySignatureTransformations(AST.createTypeLiteral(fromPropertySignatures, []), AST.createTypeLiteral(toPropertySignatures, []), propertySignatureTransformations));
  } else {
    return make(AST.createTypeLiteral(propertySignatures, []));
  }
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.struct = struct;
const pick = (...keys) => self => {
  const ast = self.ast;
  if (AST.isTransform(ast) && ast.propertySignatureTransformations.length > 0) {
    return make(AST.createTransformByPropertySignatureTransformations(AST.pick(ast.from, keys), AST.pick(ast.to, keys), ast.propertySignatureTransformations.filter(t => keys.includes(t.to))));
  }
  return make(AST.pick(ast, keys));
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.pick = pick;
const omit = (...keys) => self => {
  const ast = self.ast;
  if (AST.isTransform(ast) && ast.propertySignatureTransformations.length > 0) {
    return make(AST.createTransformByPropertySignatureTransformations(AST.omit(ast.from, keys), AST.omit(ast.to, keys), ast.propertySignatureTransformations.filter(t => !keys.includes(t.to))));
  }
  return make(AST.omit(ast, keys));
};
/**
 * Returns a nominal branded schema by applying a brand to a given schema.
 *
 * ```
 * Schema<A> + B -> Schema<A & Brand<B>>
 * ```
 *
 * @param self - The input schema to be combined with the brand.
 * @param brand - The brand to apply.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const Int = S.number.pipe(S.int(), S.brand("Int"))
 * type Int = S.To<typeof Int> // number & Brand<"Int">
 *
 * @category combinators
 * @since 1.0.0
 */
exports.omit = omit;
const brand = (brand, options) => self => {
  const annotations = toAnnotations(options);
  annotations[AST.BrandAnnotationId] = [...getBrands(self.ast), brand];
  const ast = AST.mergeAnnotations(self.ast, annotations);
  const schema = make(ast);
  const validate = P.validateSync(schema);
  const validateOption = P.validateOption(schema);
  const validateEither = P.validateEither(schema);
  const is = P.is(schema);
  const out = Object.assign(input => validate(input), {
    [_Brand.RefinedConstructorsTypeId]: _Brand.RefinedConstructorsTypeId,
    _id: TypeId,
    ast,
    option: input => validateOption(input),
    either: input => E.mapLeft(validateEither(input), e => [{
      meta: input,
      message: (0, _TreeFormatter.formatErrors)(e.errors)
    }]),
    refine: input => is(input),
    pipe() {
      return (0, _Pipeable.pipeArguments)(this, arguments);
    }
  });
  return out;
};
exports.brand = brand;
const getBrands = ast => ast.annotations[AST.BrandAnnotationId] || [];
/**
 * @category combinators
 * @since 1.0.0
 */
const partial = self => make(AST.partial(self.ast));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.partial = partial;
const required = self => make(AST.required(self.ast));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.required = required;
const record = (key, value) => make(AST.createRecord(key.ast, value.ast, true));
exports.record = record;
const intersectUnionMembers = (xs, ys) => {
  return AST.createUnion(xs.flatMap(x => {
    return ys.map(y => {
      if (AST.isTypeLiteral(x)) {
        if (AST.isTypeLiteral(y)) {
          // isTypeLiteral(x) && isTypeLiteral(y)
          return AST.createTypeLiteral(x.propertySignatures.concat(y.propertySignatures), x.indexSignatures.concat(y.indexSignatures));
        } else if (AST.isTransform(y) && y.propertySignatureTransformations.length > 0 && AST.isTypeLiteral(y.from) && AST.isTypeLiteral(y.to)) {
          // isTypeLiteral(x) && isTransform(y)
          const from = AST.createTypeLiteral(x.propertySignatures.concat(y.from.propertySignatures), x.indexSignatures.concat(y.from.indexSignatures));
          const to = AST.createTypeLiteral(AST.getToPropertySignatures(x.propertySignatures).concat(y.to.propertySignatures), AST.getToIndexSignatures(x.indexSignatures).concat(y.to.indexSignatures));
          return AST.createTransformByPropertySignatureTransformations(from, to, y.propertySignatureTransformations);
        }
      } else if (AST.isTransform(x) && x.propertySignatureTransformations.length > 0 && AST.isTypeLiteral(x.from) && AST.isTypeLiteral(x.to)) {
        if (AST.isTypeLiteral(y)) {
          // isTransform(x) && isTypeLiteral(y)
          const from = AST.createTypeLiteral(x.from.propertySignatures.concat(y.propertySignatures), x.from.indexSignatures.concat(y.indexSignatures));
          const to = AST.createTypeLiteral(x.to.propertySignatures.concat(AST.getToPropertySignatures(y.propertySignatures)), x.to.indexSignatures.concat(AST.getToIndexSignatures(y.indexSignatures)));
          return AST.createTransformByPropertySignatureTransformations(from, to, x.propertySignatureTransformations);
        } else if (AST.isTransform(y) && y.propertySignatureTransformations.length > 0 && AST.isTypeLiteral(y.from) && AST.isTypeLiteral(y.to)) {
          // isTransform(x) && isTransform(y)
          const from = AST.createTypeLiteral(x.from.propertySignatures.concat(y.from.propertySignatures), x.from.indexSignatures.concat(y.from.indexSignatures));
          const to = AST.createTypeLiteral(x.to.propertySignatures.concat(y.to.propertySignatures), x.to.indexSignatures.concat(y.to.indexSignatures));
          const propertySignatureTransformations = x.propertySignatureTransformations.concat(y.propertySignatureTransformations);
          return AST.createTransformByPropertySignatureTransformations(from, to, propertySignatureTransformations);
        }
      }
      throw new Error("`extend` can only handle type literals or unions of type literals");
    });
  }));
};
/**
 * @category combinators
 * @since 1.0.0
 */
const extend = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => make(intersectUnionMembers(AST.isUnion(self.ast) ? self.ast.types : [self.ast], AST.isUnion(that.ast) ? that.ast.types : [that.ast])));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.extend = extend;
const compose = /*#__PURE__*/(0, _Function.dual)(2, (ab, bc) => transform(ab, bc, _Function.identity, _Function.identity));
/**
 * @category combinators
 * @since 1.0.0
 */
exports.compose = compose;
const lazy = (f, annotations) => make(AST.createLazy(() => f().ast, annotations));
exports.lazy = lazy;
const toAnnotations = options => {
  const annotations = {};
  if (options?.typeId !== undefined) {
    const typeId = options?.typeId;
    if (typeof typeId === "object") {
      annotations[AST.TypeAnnotationId] = typeId.id;
      annotations[typeId.id] = typeId.params;
    } else {
      annotations[AST.TypeAnnotationId] = typeId;
    }
  }
  if (options?.message !== undefined) {
    annotations[AST.MessageAnnotationId] = options?.message;
  }
  if (options?.identifier !== undefined) {
    annotations[AST.IdentifierAnnotationId] = options?.identifier;
  }
  if (options?.title !== undefined) {
    annotations[AST.TitleAnnotationId] = options?.title;
  }
  if (options?.description !== undefined) {
    annotations[AST.DescriptionAnnotationId] = options?.description;
  }
  if (options?.examples !== undefined) {
    annotations[AST.ExamplesAnnotationId] = options?.examples;
  }
  if (options?.documentation !== undefined) {
    annotations[AST.DocumentationAnnotationId] = options?.documentation;
  }
  if (options?.jsonSchema !== undefined) {
    annotations[AST.JSONSchemaAnnotationId] = options?.jsonSchema;
  }
  if (options?.arbitrary !== undefined) {
    annotations[I.ArbitraryHookId] = options?.arbitrary;
  }
  return annotations;
};
function filter(predicate, options) {
  return self => {
    const decode = a => predicate(a) ? PR.success(a) : PR.failure(PR.type(ast, a));
    const ast = AST.createRefinement(self.ast, decode, false, toAnnotations(options));
    return make(ast);
  };
}
/**
  Create a new `Schema` by transforming the input and output of an existing `Schema`
  using the provided decoding functions.

  @category combinators
  @since 1.0.0
 */
const transformResult = /*#__PURE__*/(0, _Function.dual)(4, (from, to, decode, encode) => make(AST.createTransform(from.ast, to.ast, decode, encode)));
/**
  Create a new `Schema` by transforming the input and output of an existing `Schema`
  using the provided mapping functions.

  @category combinators
  @since 1.0.0
*/
exports.transformResult = transformResult;
const transform = /*#__PURE__*/(0, _Function.dual)(4, (from, to, decode, encode) => transformResult(from, to, a => E.right(decode(a)), b => E.right(encode(b))));
/**
 * Attaches a property signature with the specified key and value to the schema.
 * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
 * but rather maps to another schema, for example when you want to add a discriminant to a simple union.
 *
 * @param self - The input schema.
 * @param key - The name of the property to add to the schema.
 * @param value - The value of the property to add to the schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { pipe } from "@effect/data/Function"
 *
 * const Circle = S.struct({ radius: S.number })
 * const Square = S.struct({ sideLength: S.number })
 * const Shape = S.union(
 *   Circle.pipe(S.attachPropertySignature("kind", "circle")),
 *   Square.pipe(S.attachPropertySignature("kind", "square"))
 * )
 *
 * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
 *   kind: "circle",
 *   radius: 10
 * })
 *
 * @category combinators
 * @since 1.0.0
 */
exports.transform = transform;
const attachPropertySignature = (key, value) => schema => make(AST.createTransformByPropertySignatureTransformations(schema.ast, to(schema).pipe(extend(struct({
  [key]: literal(value)
}))).ast, [AST.createPropertySignatureTransformation(key, key, () => O.some(value), () => O.none())]));
// ---------------------------------------------
// annotations
// ---------------------------------------------
/**
 * @category combinators
 * @since 1.0.0
 */
exports.attachPropertySignature = attachPropertySignature;
const annotations = annotations => self => make(AST.mergeAnnotations(self.ast, annotations));
/**
 * @category annotations
 * @since 1.0.0
 */
exports.annotations = annotations;
const message = message => self => make(AST.setAnnotation(self.ast, AST.MessageAnnotationId, message));
/**
 * @category annotations
 * @since 1.0.0
 */
exports.message = message;
const identifier = identifier => self => make(AST.setAnnotation(self.ast, AST.IdentifierAnnotationId, identifier));
/**
 * @category annotations
 * @since 1.0.0
 */
exports.identifier = identifier;
const title = title => self => make(AST.setAnnotation(self.ast, AST.TitleAnnotationId, title));
/**
 * @category annotations
 * @since 1.0.0
 */
exports.title = title;
const description = description => self => make(AST.setAnnotation(self.ast, AST.DescriptionAnnotationId, description));
/**
 * @category annotations
 * @since 1.0.0
 */
exports.description = description;
const examples = examples => self => make(AST.setAnnotation(self.ast, AST.ExamplesAnnotationId, examples));
/**
 * @category annotations
 * @since 1.0.0
 */
exports.examples = examples;
const documentation = documentation => self => make(AST.setAnnotation(self.ast, AST.DocumentationAnnotationId, documentation));
// ---------------------------------------------
// data
// ---------------------------------------------
exports.documentation = documentation;
const _undefined = /*#__PURE__*/make(AST.undefinedKeyword);
exports.undefined = _undefined;
const _void = /*#__PURE__*/make(AST.voidKeyword);
exports.void = _void;
const _null = /*#__PURE__*/make( /*#__PURE__*/AST.createLiteral(null));
exports.null = _null;
/**
 * @category primitives
 * @since 1.0.0
 */
const never = /*#__PURE__*/make(AST.neverKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
exports.never = never;
const unknown = /*#__PURE__*/make(AST.unknownKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
exports.unknown = unknown;
const any = /*#__PURE__*/make(AST.anyKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
exports.any = any;
const string = /*#__PURE__*/make(AST.stringKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
exports.string = string;
const number = /*#__PURE__*/make(AST.numberKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
exports.number = number;
const boolean = /*#__PURE__*/make(AST.booleanKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
exports.boolean = boolean;
const bigint = /*#__PURE__*/make(AST.bigIntKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
exports.bigint = bigint;
const symbol = /*#__PURE__*/make(AST.symbolKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
exports.symbol = symbol;
const object = /*#__PURE__*/make(AST.objectKeyword);
// ---------------------------------------------
// data/Bigint
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
exports.object = object;
const GreaterThanBigintTypeId = "@effect/schema/GreaterThanBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
exports.GreaterThanBigintTypeId = GreaterThanBigintTypeId;
const greaterThanBigint = (min, options) => self => self.pipe(filter(a => a > min, {
  typeId: GreaterThanBigintTypeId,
  description: `a bigint greater than ${min}n`,
  jsonSchema: {
    exclusiveMinimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanBigint = greaterThanBigint;
const GreaterThanOrEqualToBigintTypeId = "@effect/schema/GreaterThanOrEqualToBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
exports.GreaterThanOrEqualToBigintTypeId = GreaterThanOrEqualToBigintTypeId;
const greaterThanOrEqualToBigint = (min, options) => self => self.pipe(filter(a => a >= min, {
  typeId: GreaterThanOrEqualToBigintTypeId,
  description: `a bigint greater than or equal to ${min}n`,
  jsonSchema: {
    minimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanOrEqualToBigint = greaterThanOrEqualToBigint;
const LessThanBigintTypeId = "@effect/schema/LessThanBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
exports.LessThanBigintTypeId = LessThanBigintTypeId;
const lessThanBigint = (max, options) => self => self.pipe(filter(a => a < max, {
  typeId: LessThanBigintTypeId,
  description: `a bigint less than ${max}n`,
  jsonSchema: {
    exclusiveMaximum: max
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanBigint = lessThanBigint;
const LessThanOrEqualToBigintTypeId = "@effect/schema/LessThanOrEqualToBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
exports.LessThanOrEqualToBigintTypeId = LessThanOrEqualToBigintTypeId;
const lessThanOrEqualToBigint = (max, options) => self => self.pipe(filter(a => a <= max, {
  typeId: LessThanOrEqualToBigintTypeId,
  description: `a bigint less than or equal to ${max}n`,
  jsonSchema: {
    maximum: max
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanOrEqualToBigint = lessThanOrEqualToBigint;
const BetweenBigintTypeId = "@effect/schema/BetweenBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
exports.BetweenBigintTypeId = BetweenBigintTypeId;
const betweenBigint = (min, max, options) => self => self.pipe(filter(a => a >= min && a <= max, {
  typeId: BetweenBigintTypeId,
  description: `a bigint between ${min}n and ${max}n`,
  jsonSchema: {
    maximum: max,
    minimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.betweenBigint = betweenBigint;
const PositiveBigintTypeId = "@effect/schema/PositiveBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
exports.PositiveBigintTypeId = PositiveBigintTypeId;
const positiveBigint = options => greaterThanBigint(0n, {
  typeId: PositiveBigintTypeId,
  description: "a positive bigint",
  ...options
});
/**
 * @category type id
 * @since 1.0.0
 */
exports.positiveBigint = positiveBigint;
const NegativeBigintTypeId = "@effect/schema/NegativeBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
exports.NegativeBigintTypeId = NegativeBigintTypeId;
const negativeBigint = options => lessThanBigint(0n, {
  typeId: NegativeBigintTypeId,
  description: "a negative bigint",
  ...options
});
/**
 * @category type id
 * @since 1.0.0
 */
exports.negativeBigint = negativeBigint;
const NonNegativeBigintTypeId = "@effect/schema/NonNegativeBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
exports.NonNegativeBigintTypeId = NonNegativeBigintTypeId;
const nonNegativeBigint = options => greaterThanOrEqualToBigint(0n, {
  typeId: NonNegativeBigintTypeId,
  description: "a non-negative bigint",
  ...options
});
/**
 * @category type id
 * @since 1.0.0
 */
exports.nonNegativeBigint = nonNegativeBigint;
const NonPositiveBigintTypeId = "@effect/schema/NonPositiveBigintTypeId";
/**
 * @category bigint
 * @since 1.0.0
 */
exports.NonPositiveBigintTypeId = NonPositiveBigintTypeId;
const nonPositiveBigint = options => lessThanOrEqualToBigint(0n, {
  typeId: NonPositiveBigintTypeId,
  description: "a non-positive bigint",
  ...options
});
/**
 * Clamps a bigint between a minimum and a maximum value.
 *
 * @category bigint
 * @since 1.0.0
 */
exports.nonPositiveBigint = nonPositiveBigint;
const clampBigint = (min, max) => self => transform(self, self.pipe(to, betweenBigint(min, max)), self => B.clamp(self, min, max),
// this is safe because `self.pipe(to, betweenBigint(min, max))` will check its input anyway
_Function.identity);
/**
 * This combinator transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * @param self - The schema representing the input string
 *
 * @category bigint
 * @since 1.0.0
 */
exports.clampBigint = clampBigint;
const bigintFromString = self => {
  const schema = transformResult(self, bigint, s => {
    if (s.trim() === "") {
      return PR.failure(PR.type(schema.ast, s));
    }
    try {
      return PR.success(BigInt(s));
    } catch (_) {
      return PR.failure(PR.type(schema.ast, s));
    }
  }, n => PR.success(String(n)) // this is safe because `self` will check its input anyway
  );

  return schema;
};
/**
 * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * @category bigint
 * @since 1.0.0
 */
exports.bigintFromString = bigintFromString;
const BigintFromString = /*#__PURE__*/bigintFromString(string);
// ---------------------------------------------
// data/Boolean
// ---------------------------------------------
/**
 * Negates a boolean value
 *
 * @category boolean
 * @since 1.0.0
 */
exports.BigintFromString = BigintFromString;
const not = self => transform(self, to(self), self => !self, self => !self);
// ---------------------------------------------
// data/Brand
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
exports.not = not;
const BrandTypeId = "@effect/schema/BrandTypeId";
/**
 * @category combinators
 * @since 1.0.0
 */
exports.BrandTypeId = BrandTypeId;
const fromBrand = (constructor, options) => self => {
  const decode = a => E.mapLeft(constructor.either(a), brandErrors => PR.parseError([PR.type(ast, a, brandErrors.map(v => v.message).join(", "))]));
  const ast = AST.createRefinement(self.ast, decode, false, toAnnotations({
    typeId: BrandTypeId,
    ...options
  }));
  return make(ast);
};
// ---------------------------------------------
// data/Chunk
// ---------------------------------------------
exports.fromBrand = fromBrand;
const chunkArbitrary = item => fc => fc.array(item(fc)).map(C.fromIterable);
const chunkPretty = item => c => `Chunk(${C.toReadonlyArray(c).map(item).join(", ")})`;
/**
 * @category constructors
 * @since 1.0.0
 */
const chunkFromSelf = item => {
  const schema = declare([item], struct({
    _id: uniqueSymbol(Symbol.for("@effect/data/Chunk")),
    length: number
  }), item => {
    const parse = P.parseResult(array(item));
    return (u, options) => !C.isChunk(u) ? PR.failure(PR.type(schema.ast, u)) : PR.map(parse(C.toReadonlyArray(u), options), C.fromIterable);
  }, {
    [AST.IdentifierAnnotationId]: "Chunk",
    [I.PrettyHookId]: chunkPretty,
    [I.ArbitraryHookId]: chunkArbitrary
  });
  return schema;
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.chunkFromSelf = chunkFromSelf;
const chunk = item => transform(array(item), to(chunkFromSelf(item)), C.fromIterable, C.toReadonlyArray);
// ---------------------------------------------
// data/Data
// ---------------------------------------------
exports.chunk = chunk;
const toData = a => Array.isArray(a) ? D.array(a) : D.struct(a);
const dataArbitrary = item => fc => item(fc).map(toData);
const dataPretty = item => d => `Data(${item(d)})`;
/**
 * @category combinators
 * @since 1.0.0
 */
const dataFromSelf = item => {
  const schema = declare([item], item, item => {
    const parse = P.parseResult(item);
    return (u, options) => !Equal.isEqual(u) ? PR.failure(PR.type(schema.ast, u)) : PR.map(parse(u, options), toData);
  }, {
    [AST.IdentifierAnnotationId]: "Data",
    [I.PrettyHookId]: dataPretty,
    [I.ArbitraryHookId]: dataArbitrary
  });
  return schema;
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.dataFromSelf = dataFromSelf;
const data = item => transform(item, to(dataFromSelf(item)), toData, a => Array.isArray(a) ? Array.from(a) : Object.assign({}, a));
// ---------------------------------------------
// data/Date
// ---------------------------------------------
exports.data = data;
const dateArbitrary = () => fc => fc.date();
const datePretty = () => date => `new Date(${JSON.stringify(date)})`;
/**
 * @category Date
 * @since 1.0.0
 */
const DateFromSelf = /*#__PURE__*/declare([], /*#__PURE__*/struct({}), () => u => !(0, _Predicate.isDate)(u) ? PR.failure(PR.type(DateFromSelf.ast, u)) : PR.success(u), {
  [AST.IdentifierAnnotationId]: "Date",
  [I.PrettyHookId]: datePretty,
  [I.ArbitraryHookId]: dateArbitrary
});
/**
 * @category type id
 * @since 1.0.0
 */
exports.DateFromSelf = DateFromSelf;
const ValidDateTypeId = "@effect/schema/ValidDateTypeId";
/**
 * A filter excluding invalid dates (e.g. `new Date("fail")`).
 *
 * @category Date
 * @since 1.0.0
 */
exports.ValidDateTypeId = ValidDateTypeId;
const validDate = options => self => self.pipe(filter(a => !isNaN(a.getTime()), {
  typeId: ValidDateTypeId,
  description: "a valid Date",
  ...options
}));
/**
 * A schema representing valid dates, e.g. `new Date("fail")` is excluded, even though it is an instance of `Date`.
 *
 * @category Date
 * @since 1.0.0
 */
exports.validDate = validDate;
const ValidDateFromSelf = /*#__PURE__*/DateFromSelf.pipe( /*#__PURE__*/validDate());
/**
  A combinator that transforms a `string` into a valid `Date`.

  @category Date
  @since 1.0.0
*/
exports.ValidDateFromSelf = ValidDateFromSelf;
const dateFromString = self => {
  const schema = transformResult(self, ValidDateFromSelf, s => PR.success(new Date(s)), n => PR.success(n.toISOString()) // this is safe because `self` will check its input anyway
  );

  return schema;
};
exports.dateFromString = dateFromString;
const _Date = /*#__PURE__*/dateFromString(string);
exports.Date = _Date;
// ---------------------------------------------
// data/Either
// ---------------------------------------------
const eitherArbitrary = (left, right) => fc => fc.oneof(left(fc).map(E.left), right(fc).map(E.right));
const eitherPretty = (left, right) => E.match({
  onLeft: e => `left(${left(e)})`,
  onRight: a => `right(${right(a)})`
});
const eitherInline = (left, right) => union(struct({
  _tag: literal("Left"),
  left
}), struct({
  _tag: literal("Right"),
  right
}));
/**
 * @category combinators
 * @since 1.0.0
 */
const eitherFromSelf = (left, right) => {
  const schema = declare([left, right], eitherInline(left, right), (left, right) => {
    const parseLeft = P.parseResult(left);
    const parseRight = P.parseResult(right);
    return (u, options) => !E.isEither(u) ? PR.failure(PR.type(schema.ast, u)) : E.isLeft(u) ? PR.map(parseLeft(u.left, options), E.left) : PR.map(parseRight(u.right, options), E.right);
  }, {
    [AST.IdentifierAnnotationId]: "Either",
    [I.PrettyHookId]: eitherPretty,
    [I.ArbitraryHookId]: eitherArbitrary
  });
  return schema;
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.eitherFromSelf = eitherFromSelf;
const either = (left, right) => transform(eitherInline(left, right), to(eitherFromSelf(left, right)), a => a._tag === "Left" ? E.left(a.left) : E.right(a.right), E.match({
  onLeft: left => ({
    _tag: "Left",
    left
  }),
  onRight: right => ({
    _tag: "Right",
    right
  })
}));
// ---------------------------------------------
// data/Json
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
exports.either = either;
const JsonNumberTypeId = "@effect/schema/JsonNumberTypeId";
/**
 * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
 * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
 * format.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const is = S.is(S.JsonNumber)
 *
 * assert.deepStrictEqual(is(42), true)
 * assert.deepStrictEqual(is(Number.NaN), false)
 * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
 * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
 *
 * @category constructors
 * @since 1.0.0
 */
exports.JsonNumberTypeId = JsonNumberTypeId;
const JsonNumber = /*#__PURE__*/number.pipe( /*#__PURE__*/filter(n => !isNaN(n) && isFinite(n), {
  typeId: JsonNumberTypeId,
  description: "a JSON number"
}));
// ---------------------------------------------
// data/Number
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
exports.JsonNumber = JsonNumber;
const FiniteTypeId = "@effect/schema/FiniteTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.FiniteTypeId = FiniteTypeId;
const finite = options => self => self.pipe(filter(a => Number.isFinite(a), {
  typeId: FiniteTypeId,
  description: "a finite number",
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.finite = finite;
const GreaterThanTypeId = "@effect/schema/GreaterThanTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.GreaterThanTypeId = GreaterThanTypeId;
const greaterThan = (min, options) => self => self.pipe(filter(a => a > min, {
  typeId: GreaterThanTypeId,
  description: `a number greater than ${min}`,
  jsonSchema: {
    exclusiveMinimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThan = greaterThan;
const GreaterThanOrEqualToTypeId = "@effect/schema/GreaterThanOrEqualToTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.GreaterThanOrEqualToTypeId = GreaterThanOrEqualToTypeId;
const greaterThanOrEqualTo = (min, options) => self => self.pipe(filter(a => a >= min, {
  typeId: GreaterThanOrEqualToTypeId,
  description: `a number greater than or equal to ${min}`,
  jsonSchema: {
    minimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanOrEqualTo = greaterThanOrEqualTo;
const MultipleOfTypeId = "@effect/schema/MultipleOfTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.MultipleOfTypeId = MultipleOfTypeId;
const multipleOf = (divisor, options) => self => self.pipe(filter(a => N.remainder(a, divisor) === 0, {
  typeId: MultipleOfTypeId,
  description: `a number divisible by ${divisor}`,
  jsonSchema: {
    multipleOf: Math.abs(divisor)
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.multipleOf = multipleOf;
const IntTypeId = "@effect/schema/IntTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.IntTypeId = IntTypeId;
const int = options => self => self.pipe(filter(a => Number.isInteger(a), {
  typeId: IntTypeId,
  description: "integer",
  jsonSchema: {
    type: "integer"
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.int = int;
const LessThanTypeId = "@effect/schema/LessThanTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.LessThanTypeId = LessThanTypeId;
const lessThan = (max, options) => self => self.pipe(filter(a => a < max, {
  typeId: LessThanTypeId,
  description: `a number less than ${max}`,
  jsonSchema: {
    exclusiveMaximum: max
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThan = lessThan;
const LessThanOrEqualToTypeId = "@effect/schema/LessThanOrEqualToTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.LessThanOrEqualToTypeId = LessThanOrEqualToTypeId;
const lessThanOrEqualTo = (max, options) => self => self.pipe(filter(a => a <= max, {
  typeId: LessThanOrEqualToTypeId,
  description: `a number less than or equal to ${max}`,
  jsonSchema: {
    maximum: max
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanOrEqualTo = lessThanOrEqualTo;
const BetweenTypeId = "@effect/schema/BetweenTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.BetweenTypeId = BetweenTypeId;
const between = (min, max, options) => self => self.pipe(filter(a => a >= min && a <= max, {
  typeId: BetweenTypeId,
  description: `a number between ${min} and ${max}`,
  jsonSchema: {
    maximum: max,
    minimum: min
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.between = between;
const NonNaNTypeId = "@effect/schema/NonNaNTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.NonNaNTypeId = NonNaNTypeId;
const nonNaN = options => self => self.pipe(filter(a => !Number.isNaN(a), {
  typeId: NonNaNTypeId,
  description: "a number NaN excluded",
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.nonNaN = nonNaN;
const PositiveTypeId = "@effect/schema/PositiveTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.PositiveTypeId = PositiveTypeId;
const positive = options => greaterThan(0, {
  typeId: PositiveTypeId,
  description: "a positive number",
  ...options
});
/**
 * @category type id
 * @since 1.0.0
 */
exports.positive = positive;
const NegativeTypeId = "@effect/schema/NegativeTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.NegativeTypeId = NegativeTypeId;
const negative = options => lessThan(0, {
  typeId: NegativeTypeId,
  description: "a negative number",
  ...options
});
/**
 * @category type id
 * @since 1.0.0
 */
exports.negative = negative;
const NonNegativeTypeId = "@effect/schema/NonNegativeTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.NonNegativeTypeId = NonNegativeTypeId;
const nonNegative = options => greaterThanOrEqualTo(0, {
  typeId: NonNegativeTypeId,
  description: "a non-negative number",
  ...options
});
/**
 * @category type id
 * @since 1.0.0
 */
exports.nonNegative = nonNegative;
const NonPositiveTypeId = "@effect/schema/NonPositiveTypeId";
/**
 * @category number
 * @since 1.0.0
 */
exports.NonPositiveTypeId = NonPositiveTypeId;
const nonPositive = options => lessThanOrEqualTo(0, {
  typeId: NonPositiveTypeId,
  description: "a non-positive number",
  ...options
});
/**
 * Clamps a number between a minimum and a maximum value.
 *
 * @category number
 * @since 1.0.0
 */
exports.nonPositive = nonPositive;
const clamp = (min, max) => self => transform(self, self.pipe(to, between(min, max)), self => N.clamp(self, min, max),
// this is safe because `self.pipe(to, between(min, max))` will check its input anyway
_Function.identity);
/**
 * This combinator transforms a `string` into a `number` by parsing the string using the `Number` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @param self - The schema representing the input string
 *
 * @category number
 * @since 1.0.0
 */
exports.clamp = clamp;
const numberFromString = self => {
  const schema = transformResult(self, number, s => {
    if (s === "NaN") {
      return PR.success(NaN);
    }
    if (s === "Infinity") {
      return PR.success(Infinity);
    }
    if (s === "-Infinity") {
      return PR.success(-Infinity);
    }
    if (s.trim() === "") {
      return PR.failure(PR.type(schema.ast, s));
    }
    const n = Number(s);
    return isNaN(n) ? PR.failure(PR.type(schema.ast, s)) : PR.success(n);
  }, n => PR.success(String(n)) // this is safe because `self` will check its input anyway
  );

  return schema;
};
/**
 * This schema transforms a `string` into a `number` by parsing the string using the `Number` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category number
 * @since 1.0.0
 */
exports.numberFromString = numberFromString;
const NumberFromString = /*#__PURE__*/numberFromString(string);
// ---------------------------------------------
// data/Object
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
exports.NumberFromString = NumberFromString;
const InstanceOfTypeId = "@effect/schema/InstanceOfTypeId";
/**
 * @category constructors
 * @since 1.0.0
 */
exports.InstanceOfTypeId = InstanceOfTypeId;
const instanceOf = (constructor, options) => {
  const annotations = toAnnotations(options);
  const schema = declare([], struct({}), () => input => input instanceof constructor ? PR.success(input) : PR.failure(PR.type(schema.ast, input)), {
    [AST.TypeAnnotationId]: InstanceOfTypeId,
    [InstanceOfTypeId]: {
      constructor
    },
    [AST.DescriptionAnnotationId]: `an instance of ${constructor.name}`,
    ...annotations
  });
  return schema;
};
// ---------------------------------------------
// data/Option
// ---------------------------------------------
exports.instanceOf = instanceOf;
const optionArbitrary = value => fc => fc.oneof(fc.constant(O.none()), value(fc).map(O.some));
const optionPretty = value => O.match({
  onNone: () => "none()",
  onSome: a => `some(${value(a)})`
});
const optionInline = value => union(struct({
  _tag: literal("None")
}), struct({
  _tag: literal("Some"),
  value
}));
/**
 * @category combinators
 * @since 1.0.0
 */
const optionFromSelf = value => {
  const schema = declare([value], optionInline(value), value => {
    const parse = P.parseResult(value);
    return (u, options) => !O.isOption(u) ? PR.failure(PR.type(schema.ast, u)) : O.isNone(u) ? PR.success(O.none()) : PR.map(parse(u.value, options), O.some);
  }, {
    [AST.IdentifierAnnotationId]: "Option",
    [I.PrettyHookId]: optionPretty,
    [I.ArbitraryHookId]: optionArbitrary
  });
  return schema;
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.optionFromSelf = optionFromSelf;
const option = value => transform(optionInline(value), to(optionFromSelf(value)), a => a._tag === "None" ? O.none() : O.some(a.value), O.match({
  onNone: () => ({
    _tag: "None"
  }),
  onSome: value => ({
    _tag: "Some",
    value
  })
}));
/**
 * @category option
 * @since 1.0.0
 */
exports.option = option;
const optionFromNullable = value => transform(nullable(value), to(optionFromSelf(value)), O.fromNullable, O.getOrNull);
// ---------------------------------------------
// data/ReadonlyArray
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
exports.optionFromNullable = optionFromNullable;
const MinItemsTypeId = "@effect/schema/MinItemsTypeId";
/**
 * @category array
 * @since 1.0.0
 */
exports.MinItemsTypeId = MinItemsTypeId;
const minItems = (n, options) => self => self.pipe(filter(a => a.length >= n, {
  typeId: MinItemsTypeId,
  description: `an array of at least ${n} items`,
  jsonSchema: {
    minItems: n
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.minItems = minItems;
const MaxItemsTypeId = "@effect/schema/MaxItemsTypeId";
/**
 * @category array
 * @since 1.0.0
 */
exports.MaxItemsTypeId = MaxItemsTypeId;
const maxItems = (n, options) => self => self.pipe(filter(a => a.length <= n, {
  typeId: MaxItemsTypeId,
  description: `an array of at most ${n} items`,
  jsonSchema: {
    maxItems: n
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.maxItems = maxItems;
const ItemsCountTypeId = "@effect/schema/ItemsCountTypeId";
/**
 * @category array
 * @since 1.0.0
 */
exports.ItemsCountTypeId = ItemsCountTypeId;
const itemsCount = (n, options) => self => self.pipe(filter(a => a.length === n, {
  typeId: ItemsCountTypeId,
  description: `an array of exactly ${n} items`,
  jsonSchema: {
    minItems: n,
    maxItems: n
  },
  ...options
}));
// ---------------------------------------------
// data/ReadonlyMap
// ---------------------------------------------
exports.itemsCount = itemsCount;
const isMap = u => u instanceof Map;
const readonlyMapArbitrary = (key, value) => fc => fc.array(fc.tuple(key(fc), value(fc))).map(as => new Map(as));
const readonlyMapPretty = (key, value) => map => `new Map([${Array.from(map.entries()).map(([k, v]) => `[${key(k)}, ${value(v)}]`).join(", ")}])`;
/**
 * @category constructors
 * @since 1.0.0
 */
const readonlyMapFromSelf = (key, value) => {
  const schema = declare([key, value], struct({
    size: number
  }), (key, value) => {
    const parse = P.parseResult(array(tuple(key, value)));
    return (u, options) => !isMap(u) ? PR.failure(PR.type(schema.ast, u)) : PR.map(parse(Array.from(u.entries()), options), as => new Map(as));
  }, {
    [AST.IdentifierAnnotationId]: "ReadonlyMap",
    [I.PrettyHookId]: readonlyMapPretty,
    [I.ArbitraryHookId]: readonlyMapArbitrary
  });
  return schema;
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.readonlyMapFromSelf = readonlyMapFromSelf;
const readonlyMap = (key, value) => transform(array(tuple(key, value)), to(readonlyMapFromSelf(key, value)), as => new Map(as), map => Array.from(map.entries()));
// ---------------------------------------------
// data/ReadonlySet
// ---------------------------------------------
exports.readonlyMap = readonlyMap;
const isSet = u => u instanceof Set;
const readonlySetArbitrary = item => fc => fc.array(item(fc)).map(as => new Set(as));
const readonlySetPretty = item => set => `new Set([${Array.from(set.values()).map(a => item(a)).join(", ")}])`;
/**
 * @category constructors
 * @since 1.0.0
 */
const readonlySetFromSelf = item => {
  const schema = declare([item], struct({
    size: number
  }), item => {
    const parse = P.parseResult(array(item));
    return (u, options) => !isSet(u) ? PR.failure(PR.type(schema.ast, u)) : PR.map(parse(Array.from(u.values()), options), as => new Set(as));
  }, {
    [AST.IdentifierAnnotationId]: "ReadonlySet",
    [I.PrettyHookId]: readonlySetPretty,
    [I.ArbitraryHookId]: readonlySetArbitrary
  });
  return schema;
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.readonlySetFromSelf = readonlySetFromSelf;
const readonlySet = item => transform(array(item), to(readonlySetFromSelf(item)), as => new Set(as), set => Array.from(set));
// ---------------------------------------------
// data/String
// ---------------------------------------------
/**
 * @category type id
 * @since 1.0.0
 */
exports.readonlySet = readonlySet;
const TrimmedTypeId = "@effect/schema/TrimmedTypeId";
/**
 * Verifies that a string contains no leading or trailing whitespaces.
 *
 * Note. This combinator does not make any transformations, it only validates.
 * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.
 *
 * @category string
 * @since 1.0.0
 */
exports.TrimmedTypeId = TrimmedTypeId;
const trimmed = options => self => self.pipe(filter(a => a === a.trim(), {
  typeId: TrimmedTypeId,
  description: "a string with no leading or trailing whitespace",
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.trimmed = trimmed;
const MaxLengthTypeId = "@effect/schema/MaxLengthTypeId";
/**
 * @category string
 * @since 1.0.0
 */
exports.MaxLengthTypeId = MaxLengthTypeId;
const maxLength = (maxLength, options) => self => self.pipe(filter(a => a.length <= maxLength, {
  typeId: MaxLengthTypeId,
  description: `a string at most ${maxLength} character(s) long`,
  jsonSchema: {
    maxLength
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.maxLength = maxLength;
const MinLengthTypeId = "@effect/schema/MinLengthTypeId";
/**
 * @category string
 * @since 1.0.0
 */
exports.MinLengthTypeId = MinLengthTypeId;
const minLength = (minLength, options) => self => self.pipe(filter(a => a.length >= minLength, {
  typeId: MinLengthTypeId,
  description: `a string at least ${minLength} character(s) long`,
  jsonSchema: {
    minLength
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.minLength = minLength;
const PatternTypeId = "@effect/schema/PatternTypeId";
/**
 * @category string
 * @since 1.0.0
 */
exports.PatternTypeId = PatternTypeId;
const pattern = (regex, options) => self => {
  const pattern = regex.source;
  return self.pipe(filter(a => {
    // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    typeId: {
      id: PatternTypeId,
      params: {
        regex
      }
    },
    description: `a string matching the pattern ${pattern}`,
    jsonSchema: {
      pattern
    },
    ...options
  }));
};
/**
 * @category type id
 * @since 1.0.0
 */
exports.pattern = pattern;
const StartsWithTypeId = "@effect/schema/StartsWithTypeId";
/**
 * @category string
 * @since 1.0.0
 */
exports.StartsWithTypeId = StartsWithTypeId;
const startsWith = (startsWith, options) => self => self.pipe(filter(a => a.startsWith(startsWith), {
  typeId: {
    id: StartsWithTypeId,
    params: {
      startsWith
    }
  },
  description: `a string starting with ${JSON.stringify(startsWith)}`,
  jsonSchema: {
    pattern: `^${startsWith}`
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.startsWith = startsWith;
const EndsWithTypeId = "@effect/schema/EndsWithTypeId";
/**
 * @category string
 * @since 1.0.0
 */
exports.EndsWithTypeId = EndsWithTypeId;
const endsWith = (endsWith, options) => self => self.pipe(filter(a => a.endsWith(endsWith), {
  typeId: {
    id: EndsWithTypeId,
    params: {
      endsWith
    }
  },
  description: `a string ending with ${JSON.stringify(endsWith)}`,
  jsonSchema: {
    pattern: `^.*${endsWith}$`
  },
  ...options
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.endsWith = endsWith;
const IncludesTypeId = "@effect/schema/IncludesTypeId";
/**
 * @category string
 * @since 1.0.0
 */
exports.IncludesTypeId = IncludesTypeId;
const includes = (searchString, options) => self => self.pipe(filter(a => a.includes(searchString), {
  typeId: {
    id: IncludesTypeId,
    params: {
      includes: searchString
    }
  },
  description: `a string including ${JSON.stringify(searchString)}`,
  jsonSchema: {
    pattern: `.*${searchString}.*`
  },
  ...options
}));
/**
 * This combinator allows removing whitespaces from the beginning and end of a string.
 *
 * @category string
 * @since 1.0.0
 */
exports.includes = includes;
const trim = self => transform(self, to(self).pipe(trimmed()), s => s.trim(),
// this is safe because `pipe(to(self), trimmed())` will check its input anyway
_Function.identity);
/**
 * This schema allows removing whitespaces from the beginning and end of a string.
 *
 * @category string
 * @since 1.0.0
 */
exports.trim = trim;
const Trim = /*#__PURE__*/trim(string);
/**
 * This combinator allows splitting a string into an array of strings.
 *
 * @category string
 * @since 1.0.0
 */
exports.Trim = Trim;
const split = /*#__PURE__*/(0, _Function.dual)(2, (self, separator) => transform(self, array(string), S.split(separator), RA.join(separator)));
/**
 * @category type id
 * @since 1.0.0
 */
exports.split = split;
const UUIDTypeId = "@effect/schema/UUIDTypeId";
exports.UUIDTypeId = UUIDTypeId;
const uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
/**
 * @category constructors
 * @since 1.0.0
 */
const UUID = /*#__PURE__*/string.pipe( /*#__PURE__*/pattern(uuidRegex, {
  typeId: UUIDTypeId,
  title: "UUID",
  arbitrary: () => fc => fc.uuid()
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.UUID = UUID;
const ULIDTypeId = "@effect/schema/ULIDTypeId";
exports.ULIDTypeId = ULIDTypeId;
const ulidRegex = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
/**
 * @category constructors
 * @since 1.0.0
 */
const ULID = /*#__PURE__*/string.pipe( /*#__PURE__*/pattern(ulidRegex, {
  typeId: ULIDTypeId,
  title: "ULID",
  arbitrary: () => fc => fc.ulid()
}));
/**
 * @category string
 * @since 1.0.0
 */
exports.ULID = ULID;
const length = (length, options) => self => minLength(length, options)(maxLength(length)(self));
/**
 * @category string
 * @since 1.0.0
 */
exports.length = length;
const nonEmpty = options => minLength(1, options);
exports.nonEmpty = nonEmpty;
//# sourceMappingURL=Schema.js.map