import type { AnyMessage, Message } from "@bufbuild/protobuf";
import type { Interceptor, StreamRequest, StreamResponse, UnaryRequest, UnaryResponse } from "./interceptor.js";
/**
 * Runs a unary method with the given interceptors. Note that this function
 * is only used when implementing a Transport.
 *
 * @deprecated Use runUnaryCall from @bufbuild/connect/protocol instead.
 */
export declare function runUnary<I extends Message<I>, O extends Message<O>>(req: UnaryRequest<I, O>, next: UnaryFn<I, O>, interceptors: Interceptor[] | undefined): Promise<UnaryResponse<I, O>>;
/**
 * Runs a server-streaming method with the given interceptors. Note that this
 * function is only used when implementing a Transport.
 *
 * @deprecated Use runStreamingCall from @bufbuild/connect/protocol instead.
 */
export declare function runStreaming<I extends Message<I>, O extends Message<O>>(req: StreamRequest<I, O>, next: StreamingFn<I, O>, interceptors: Interceptor[] | undefined): Promise<StreamResponse<I, O>>;
/**
 * UnaryFn represents the client-side invocation of a unary RPC - a method
 * that takes a single input message, and responds with a single output
 * message.
 * A Transport implements such a function, and makes it available to
 * interceptors.
 */
type UnaryFn<I extends Message<I> = AnyMessage, O extends Message<O> = AnyMessage> = (req: UnaryRequest<I, O>) => Promise<UnaryResponse<I, O>>;
/**
 * StreamingFn represents the client-side invocation of a streaming RPC - a
 * method that takes zero or more input messages, and responds with zero or
 * more output messages.
 * A Transport implements such a function, and makes it available to
 * interceptors.
 */
type StreamingFn<I extends Message<I> = AnyMessage, O extends Message<O> = AnyMessage> = (req: StreamRequest<I, O>) => Promise<StreamResponse<I, O>>;
export {};
